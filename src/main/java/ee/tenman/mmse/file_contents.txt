Contents of files with extensions: .java, .yaml, .yml, .sql, .py, .json, .kts

File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/GeneratedByJHipster.java
package ee.tenman.mmse;

import jakarta.annotation.Generated;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Generated(value = "JHipster", comments = "Generated by JHipster 8.0.0-beta.1")
@Retention(RetentionPolicy.SOURCE)
@Target({ElementType.TYPE})
public @interface GeneratedByJHipster {
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/MmseApp.java
package ee.tenman.mmse;

import ee.tenman.mmse.config.ApplicationProperties;
import ee.tenman.mmse.config.CRLFLogConverter;
import jakarta.annotation.PostConstruct;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.liquibase.LiquibaseProperties;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.core.env.Environment;
import tech.jhipster.config.DefaultProfileUtil;
import tech.jhipster.config.JHipsterConstants;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.Arrays;
import java.util.Collection;
import java.util.Optional;

@SpringBootApplication
@EnableConfigurationProperties({LiquibaseProperties.class, ApplicationProperties.class})
@EnableFeignClients
public class MmseApp {

    private static final Logger log = LoggerFactory.getLogger(MmseApp.class);

    private final Environment env;

    public MmseApp(Environment env) {
        this.env = env;
    }

    /**
     * Initializes MMSE-App.
     * <p>
     * Spring profiles can be configured with a program argument --spring.profiles.active=your-active-profile
     * <p>
     * You can find more information on how profiles work with JHipster on <a href="https://www.jhipster.tech/profiles/">https://www.jhipster.tech/profiles/</a>.
     */
    @PostConstruct
    public void initApplication() {
        Collection<String> activeProfiles = Arrays.asList(env.getActiveProfiles());
        if (
            activeProfiles.contains(JHipsterConstants.SPRING_PROFILE_DEVELOPMENT) &&
                activeProfiles.contains(JHipsterConstants.SPRING_PROFILE_PRODUCTION)
        ) {
            log.error(
                "You have misconfigured your application! It should not run " + "with both the 'dev' and 'prod' profiles at the same time."
            );
        }
        if (
            activeProfiles.contains(JHipsterConstants.SPRING_PROFILE_DEVELOPMENT) &&
                activeProfiles.contains(JHipsterConstants.SPRING_PROFILE_CLOUD)
        ) {
            log.error(
                "You have misconfigured your application! It should not " + "run with both the 'dev' and 'cloud' profiles at the same time."
            );
        }
    }

    /**
     * Main method, used to run the application.
     *
     * @param args the command line arguments.
     */
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(MmseApp.class);
        DefaultProfileUtil.addDefaultProfile(app);
        Environment env = app.run(args).getEnvironment();
        logApplicationStartup(env);
    }

    private static void logApplicationStartup(Environment env) {
        String protocol = Optional.ofNullable(env.getProperty("server.ssl.key-store")).map(key -> "https").orElse("http");
        String serverPort = env.getProperty("server.port");
        String contextPath = Optional
            .ofNullable(env.getProperty("server.servlet.context-path"))
            .filter(StringUtils::isNotBlank)
            .orElse("/");
        String hostAddress = "localhost";
        try {
            hostAddress = InetAddress.getLocalHost().getHostAddress();
        } catch (UnknownHostException e) {
            log.warn("The host name could not be determined, using `localhost` as fallback");
        }
        log.info(
            CRLFLogConverter.CRLF_SAFE_MARKER,
            """

                ----------------------------------------------------------
                \tApplication '{}' is running! Access URLs:
                \tLocal: \t\t{}://localhost:{}{}
                \tExternal: \t{}://{}:{}{}
                \tProfile(s): \t{}
                ----------------------------------------------------------""",
            env.getProperty("spring.application.name"),
            protocol,
            serverPort,
            contextPath,
            protocol,
            hostAddress,
            serverPort,
            contextPath,
            env.getActiveProfiles().length == 0 ? env.getDefaultProfiles() : env.getActiveProfiles()
        );
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/parser.py
import os

# Specify the file extensions to search for
extensions = ['.java', '.yaml', '.yml', '.sql', '.py', '.json', '.kts']

# Specify the output file name
output_file = 'file_contents.txt'

# Function to process a file and write its contents to the output file
def process_file(file_path):
    with open(file_path, 'r', encoding='utf-8') as file:
        content = file.read()
        with open(output_file, 'a', encoding='utf-8') as output:
            output.write(f"File: {file_path}\n")
            output.write(content)
            output.write("\n\n")

# Function to recursively traverse directories and process files
def traverse_directory(directory):
    for root, dirs, files in os.walk(directory):
        for file in files:
            file_path = os.path.join(root, file)
            _, extension = os.path.splitext(file)
            if extension in extensions:
                process_file(file_path)

# Get the current directory
current_directory = os.getcwd()

# Open the output file in write mode (overwrites existing content)
with open(output_file, 'w', encoding='utf-8') as output:
    output.write(f"Contents of files with extensions: {', '.join(extensions)}\n\n")

# Traverse the current directory and its subdirectories
traverse_directory(current_directory)

print(f"File contents written to {output_file}")

File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/ApplicationWebXml.java
package ee.tenman.mmse;

import org.springframework.boot.builder.SpringApplicationBuilder;
import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;
import tech.jhipster.config.DefaultProfileUtil;

/**
 * This is a helper Java class that provides an alternative to creating a {@code web.xml}.
 * This will be invoked only when the application is deployed to a Servlet container like Tomcat, JBoss etc.
 */
public class ApplicationWebXml extends SpringBootServletInitializer {

    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
        // set a default to use when no profile is configured.
        DefaultProfileUtil.addDefaultProfile(application.application());
        return application.sources(MmseApp.class);
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/package-info.java
/**
 * Application root.
 */
package ee.tenman.mmse;


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/repository/UserAnswerRepository.java
package ee.tenman.mmse.repository;

import ee.tenman.mmse.domain.UserAnswer;
import ee.tenman.mmse.domain.enumeration.QuestionId;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

/**
 * Spring Data JPA repository for the UserAnswer entity.
 */
@SuppressWarnings("unused")
@Repository
public interface UserAnswerRepository extends JpaRepository<UserAnswer, Long> {

    @Query("SELECT u FROM UserAnswer u WHERE u.testEntity.id = :testEntityId ORDER BY u.createdAt DESC")
    List<UserAnswer> findLatestByTestEntityId(@Param("testEntityId") Long testEntityId, Pageable pageable);

    List<UserAnswer> findByTestEntityIdOrderByCreatedAtDesc(Long testEntityId);

    @Query("SELECT u FROM UserAnswer u WHERE u.score is null ORDER BY u.createdAt ASC")
    List<UserAnswer> findUnscored();

    Optional<UserAnswer> findFirstByTestEntityIdAndQuestionIdOrderByCreatedAtDesc(Long testEntityId, QuestionId questionId);

}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/repository/AuthorityRepository.java
package ee.tenman.mmse.repository;

import ee.tenman.mmse.domain.Authority;
import org.springframework.data.jpa.repository.JpaRepository;

/**
 * Spring Data JPA repository for the {@link Authority} entity.
 */
public interface AuthorityRepository extends JpaRepository<Authority, String> {
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/repository/TestEntityRepository.java
package ee.tenman.mmse.repository;

import ee.tenman.mmse.domain.TestEntity;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

/**
 * Spring Data JPA repository for the TestEntity entity.
 */
@Repository
public interface TestEntityRepository extends JpaRepository<TestEntity, Long> {
    @Query("select testEntity from TestEntity testEntity where testEntity.user.login = ?#{principal.username}")
    List<TestEntity> findByUserIsCurrentUser();

    default Optional<TestEntity> findOneWithEagerRelationships(Long id) {
        return this.findOneWithToOneRelationships(id);
    }

    default List<TestEntity> findAllWithEagerRelationships() {
        return this.findAllWithToOneRelationships();
    }

    default Page<TestEntity> findAllWithEagerRelationships(Pageable pageable) {
        return this.findAllWithToOneRelationships(pageable);
    }

    @Query(
        value = "select testEntity from TestEntity testEntity left join fetch testEntity.user",
        countQuery = "select count(testEntity) from TestEntity testEntity"
    )
    Page<TestEntity> findAllWithToOneRelationships(Pageable pageable);

    @Query("select testEntity from TestEntity testEntity left join fetch testEntity.user")
    List<TestEntity> findAllWithToOneRelationships();

    @Query("select testEntity from TestEntity testEntity left join fetch testEntity.user where testEntity.id =:id")
    Optional<TestEntity> findOneWithToOneRelationships(@Param("id") Long id);

    @Query("SELECT t FROM TestEntity t WHERE t.user.id = :userId ORDER BY t.createdAt DESC LIMIT 1")
    List<TestEntity> findLatestByUserId(@Param("userId") Long userId, Pageable pageable);


    Optional<TestEntity> findFirstByUserIdOrderByCreatedAtDesc(Long userId);


}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/repository/UserRepository.java
package ee.tenman.mmse.repository;

import ee.tenman.mmse.domain.User;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.EntityGraph;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.Instant;
import java.util.List;
import java.util.Optional;

/**
 * Spring Data JPA repository for the {@link User} entity.
 */
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findOneByActivationKey(String activationKey);

    List<User> findAllByActivatedIsFalseAndActivationKeyIsNotNullAndCreatedDateBefore(Instant dateTime);

    Optional<User> findOneByResetKey(String resetKey);

    Optional<User> findOneByEmailIgnoreCase(String email);

    Optional<User> findOneByLogin(String login);

    @EntityGraph(attributePaths = "authorities")
    Optional<User> findOneWithAuthoritiesByLogin(String login);

    @EntityGraph(attributePaths = "authorities")
    Optional<User> findOneWithAuthoritiesByEmailIgnoreCase(String email);

    Page<User> findAllByIdNotNullAndActivatedIsTrue(Pageable pageable);
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/repository/MediaRecordingRepository.java
package ee.tenman.mmse.repository;

import ee.tenman.mmse.domain.MediaRecording;
import ee.tenman.mmse.domain.enumeration.QuestionId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface MediaRecordingRepository extends JpaRepository<MediaRecording, Long> {
    Optional<MediaRecording> findFirstByTestEntityIdAndQuestionIdOrderByCreatedAtDesc(Long testEntityId, QuestionId questionId);
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/repository/package-info.java
/**
 * Repository layer.
 */
package ee.tenman.mmse.repository;


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/config/LiquibaseConfiguration.java
package ee.tenman.mmse.config;

import liquibase.integration.spring.SpringLiquibase;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.ObjectProvider;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;
import org.springframework.boot.autoconfigure.liquibase.LiquibaseDataSource;
import org.springframework.boot.autoconfigure.liquibase.LiquibaseProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;
import org.springframework.core.env.Profiles;
import tech.jhipster.config.JHipsterConstants;
import tech.jhipster.config.liquibase.SpringLiquibaseUtil;

import javax.sql.DataSource;
import java.util.concurrent.Executor;

@Configuration
public class LiquibaseConfiguration {

    private final Logger log = LoggerFactory.getLogger(LiquibaseConfiguration.class);

    private final Environment env;

    public LiquibaseConfiguration(Environment env) {
        this.env = env;
    }

    @Bean
    public SpringLiquibase liquibase(
        @Qualifier("taskExecutor") Executor executor,
        LiquibaseProperties liquibaseProperties,
        @LiquibaseDataSource ObjectProvider<DataSource> liquibaseDataSource,
        ObjectProvider<DataSource> dataSource,
        DataSourceProperties dataSourceProperties
    ) {
        // If you don't want Liquibase to start asynchronously, substitute by this:
        // SpringLiquibase liquibase = SpringLiquibaseUtil.createSpringLiquibase(liquibaseDataSource.getIfAvailable(), liquibaseProperties, dataSource.getIfUnique(), dataSourceProperties);
        SpringLiquibase liquibase = SpringLiquibaseUtil.createAsyncSpringLiquibase(
            this.env,
            executor,
            liquibaseDataSource.getIfAvailable(),
            liquibaseProperties,
            dataSource.getIfUnique(),
            dataSourceProperties
        );
        liquibase.setChangeLog("classpath:config/liquibase/master.xml");
        liquibase.setContexts(liquibaseProperties.getContexts());
        liquibase.setDefaultSchema(liquibaseProperties.getDefaultSchema());
        liquibase.setLiquibaseSchema(liquibaseProperties.getLiquibaseSchema());
        liquibase.setLiquibaseTablespace(liquibaseProperties.getLiquibaseTablespace());
        liquibase.setDatabaseChangeLogLockTable(liquibaseProperties.getDatabaseChangeLogLockTable());
        liquibase.setDatabaseChangeLogTable(liquibaseProperties.getDatabaseChangeLogTable());
        liquibase.setDropFirst(liquibaseProperties.isDropFirst());
        liquibase.setLabelFilter(liquibaseProperties.getLabelFilter());
        liquibase.setChangeLogParameters(liquibaseProperties.getParameters());
        liquibase.setRollbackFile(liquibaseProperties.getRollbackFile());
        liquibase.setTestRollbackOnUpdate(liquibaseProperties.isTestRollbackOnUpdate());
        if (env.acceptsProfiles(Profiles.of(JHipsterConstants.SPRING_PROFILE_NO_LIQUIBASE))) {
            liquibase.setShouldRun(false);
        } else {
            liquibase.setShouldRun(liquibaseProperties.isEnabled());
            log.debug("Configuring Liquibase");
        }
        return liquibase;
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/config/RedisConfiguration.java
package ee.tenman.mmse.config;

import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.RedisConnectionFactory;

import java.time.Duration;
import java.util.HashMap;
import java.util.Map;

@Configuration
@EnableCaching
public class RedisConfiguration {

    public static final String ONE_DAY_CACHE = "one-day-cache";
    private static final Duration DEFAULT_TTL = Duration.ofMinutes(1);

    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        Map<String, RedisCacheConfiguration> cacheConfigurations = new HashMap<>();
        cacheConfigurations.put(ONE_DAY_CACHE, RedisCacheConfiguration.defaultCacheConfig().entryTtl(Duration.ofDays(1)));
        RedisCacheConfiguration defaultConfig = RedisCacheConfiguration.defaultCacheConfig().entryTtl(DEFAULT_TTL);
        return RedisCacheManager.builder(connectionFactory)
            .cacheDefaults(defaultConfig)
            .withInitialCacheConfigurations(cacheConfigurations)
            .build();
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/config/LoggingAspectConfiguration.java
package ee.tenman.mmse.config;

import ee.tenman.mmse.aop.logging.LoggingAspect;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;
import org.springframework.context.annotation.Profile;
import org.springframework.core.env.Environment;
import tech.jhipster.config.JHipsterConstants;

@Configuration
@EnableAspectJAutoProxy
public class LoggingAspectConfiguration {

    @Bean
    @Profile(JHipsterConstants.SPRING_PROFILE_DEVELOPMENT)
    public LoggingAspect loggingAspect(Environment env) {
        return new LoggingAspect(env);
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/config/SchedulingConfiguration.java
package com.tuum.banking.configuration;

import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableScheduling;

@Configuration
@EnableScheduling
public class SchedulingConfiguration {
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/config/ApplicationProperties.java
package ee.tenman.mmse.config;

import org.springframework.boot.context.properties.ConfigurationProperties;

/**
 * Properties specific to MMSE App.
 * <p>
 * Properties are configured in the {@code application.yml} file.
 * See {@link tech.jhipster.config.JHipsterProperties} for a good example.
 */
@ConfigurationProperties(prefix = "application", ignoreUnknownFields = false)
public class ApplicationProperties {
    // jhipster-needle-application-properties-property
    // jhipster-needle-application-properties-property-getter
    // jhipster-needle-application-properties-property-class
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/config/WebConfigurer.java
package ee.tenman.mmse.config;

import jakarta.servlet.ServletContext;
import jakarta.servlet.ServletException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.web.server.WebServerFactory;
import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.boot.web.servlet.ServletContextInitializer;
import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;
import org.springframework.util.CollectionUtils;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;
import tech.jhipster.config.JHipsterProperties;

import java.io.File;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;

import static java.net.URLDecoder.decode;

/**
 * Configuration of web application with Servlet 3.0 APIs.
 */
@Configuration
public class WebConfigurer implements ServletContextInitializer, WebServerFactoryCustomizer<WebServerFactory> {

    private final Logger log = LoggerFactory.getLogger(WebConfigurer.class);

    private final Environment env;

    private final JHipsterProperties jHipsterProperties;

    public WebConfigurer(Environment env, JHipsterProperties jHipsterProperties) {
        this.env = env;
        this.jHipsterProperties = jHipsterProperties;
    }

    @Override
    public void onStartup(ServletContext servletContext) throws ServletException {
        if (env.getActiveProfiles().length != 0) {
            log.info("Web application configuration, using profiles: {}", (Object[]) env.getActiveProfiles());
        }

        log.info("Web application fully configured");
    }

    /**
     * Customize the Servlet engine: Mime types, the document root, the cache.
     */
    @Override
    public void customize(WebServerFactory server) {
        // When running in an IDE or with ./mvnw spring-boot:run, set location of the static web assets.
        setLocationForStaticAssets(server);
    }

    private void setLocationForStaticAssets(WebServerFactory server) {
        if (server instanceof ConfigurableServletWebServerFactory servletWebServer) {
            File root;
            String prefixPath = resolvePathPrefix();
            root = new File(prefixPath + "target/classes/static/");
            if (root.exists() && root.isDirectory()) {
                servletWebServer.setDocumentRoot(root);
            }
        }
    }

    /**
     * Resolve path prefix to static resources.
     */
    private String resolvePathPrefix() {
        String fullExecutablePath = decode(this.getClass().getResource("").getPath(), StandardCharsets.UTF_8);
        String rootPath = Paths.get(".").toUri().normalize().getPath();
        String extractedPath = fullExecutablePath.replace(rootPath, "");
        int extractionEndIndex = extractedPath.indexOf("target/");
        if (extractionEndIndex <= 0) {
            return "";
        }
        return extractedPath.substring(0, extractionEndIndex);
    }

    @Bean
    public CorsFilter corsFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration config = jHipsterProperties.getCors();
        if (!CollectionUtils.isEmpty(config.getAllowedOrigins()) || !CollectionUtils.isEmpty(config.getAllowedOriginPatterns())) {
            log.debug("Registering CORS filter");
            source.registerCorsConfiguration("/api/**", config);
            source.registerCorsConfiguration("/management/**", config);
            source.registerCorsConfiguration("/v3/api-docs", config);
            source.registerCorsConfiguration("/swagger-ui/**", config);
        }
        return new CorsFilter(source);
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/config/DateTimeFormatConfiguration.java
package ee.tenman.mmse.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.format.FormatterRegistry;
import org.springframework.format.datetime.standard.DateTimeFormatterRegistrar;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * Configure the converters to use the ISO format for dates by default.
 */
@Configuration
public class DateTimeFormatConfiguration implements WebMvcConfigurer {

    @Override
    public void addFormatters(FormatterRegistry registry) {
        DateTimeFormatterRegistrar registrar = new DateTimeFormatterRegistrar();
        registrar.setUseIsoFormat(true);
        registrar.registerFormatters(registry);
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/config/ClockConfiguration.java
package ee.tenman.mmse.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.time.Clock;

@Configuration
public class ClockConfiguration {
    @Bean
    public Clock clock() {
        return Clock.systemDefaultZone();
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/config/SecurityJwtConfiguration.java
package ee.tenman.mmse.config;

import com.nimbusds.jose.jwk.source.ImmutableSecret;
import com.nimbusds.jose.util.Base64;
import ee.tenman.mmse.management.SecurityMetersService;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtEncoder;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusJwtEncoder;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;

import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

import static ee.tenman.mmse.security.SecurityUtils.AUTHORITIES_KEY;
import static ee.tenman.mmse.security.SecurityUtils.JWT_ALGORITHM;

@Configuration
public class SecurityJwtConfiguration {

    @Value("${jhipster.security.authentication.jwt.base64-secret}")
    private String jwtKey;

    @Bean
    public JwtDecoder jwtDecoder(SecurityMetersService metersService) {
        NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withSecretKey(getSecretKey()).macAlgorithm(JWT_ALGORITHM).build();
        return token -> {
            try {
                return jwtDecoder.decode(token);
            } catch (Exception e) {
                if (e.getMessage().contains("Invalid signature")) {
                    metersService.trackTokenInvalidSignature();
                } else if (e.getMessage().contains("Jwt expired at")) {
                    metersService.trackTokenExpired();
                } else if (e.getMessage().contains("Invalid JWT serialization")) {
                    metersService.trackTokenMalformed();
                } else if (e.getMessage().contains("Invalid unsecured/JWS/JWE")) {
                    metersService.trackTokenMalformed();
                }
                throw e;
            }
        };
    }

    @Bean
    public JwtEncoder jwtEncoder() {
        return new NimbusJwtEncoder(new ImmutableSecret<>(getSecretKey()));
    }

    @Bean
    public JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
        grantedAuthoritiesConverter.setAuthorityPrefix("");
        grantedAuthoritiesConverter.setAuthoritiesClaimName(AUTHORITIES_KEY);

        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter);
        return jwtAuthenticationConverter;
    }

    private SecretKey getSecretKey() {
        byte[] keyBytes = Base64.from(jwtKey).decode();
        return new SecretKeySpec(keyBytes, 0, keyBytes.length, JWT_ALGORITHM.getName());
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/config/DebugFilter.java
package ee.tenman.mmse.config;

import jakarta.servlet.Filter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletRequest;
import jakarta.servlet.ServletResponse;
import jakarta.servlet.http.HttpServletRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.util.Enumeration;

public class DebugFilter implements Filter {
    private static final Logger LOG = LoggerFactory.getLogger(DebugFilter.class);

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
        throws IOException, ServletException {
        HttpServletRequest httpServletRequest = (HttpServletRequest) request;
        Enumeration<String> headerNames = httpServletRequest.getHeaderNames();

        while (headerNames.hasMoreElements()) {
            String headerName = headerNames.nextElement();
//            LOG.info("Header Name: {}, Value: {}", headerName, httpServletRequest.getHeader(headerName));
        }

        chain.doFilter(request, response);
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/config/StaticResourcesWebConfiguration.java
package ee.tenman.mmse.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.http.CacheControl;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import tech.jhipster.config.JHipsterConstants;
import tech.jhipster.config.JHipsterProperties;

import java.util.concurrent.TimeUnit;

@Configuration
@Profile({JHipsterConstants.SPRING_PROFILE_PRODUCTION})
public class StaticResourcesWebConfiguration implements WebMvcConfigurer {

    protected static final String[] RESOURCE_LOCATIONS = new String[]{
        "classpath:/static/",
        "classpath:/static/content/",
        "classpath:/static/i18n/",
    };
    protected static final String[] RESOURCE_PATHS = new String[]{
        "/*.js",
        "/*.css",
        "/*.svg",
        "/*.png",
        "*.ico",
        "/content/**",
        "/i18n/*",
    };

    private final JHipsterProperties jhipsterProperties;

    public StaticResourcesWebConfiguration(JHipsterProperties jHipsterProperties) {
        this.jhipsterProperties = jHipsterProperties;
    }

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        ResourceHandlerRegistration resourceHandlerRegistration = appendResourceHandler(registry);
        initializeResourceHandler(resourceHandlerRegistration);
    }

    protected ResourceHandlerRegistration appendResourceHandler(ResourceHandlerRegistry registry) {
        return registry.addResourceHandler(RESOURCE_PATHS);
    }

    protected void initializeResourceHandler(ResourceHandlerRegistration resourceHandlerRegistration) {
        resourceHandlerRegistration.addResourceLocations(RESOURCE_LOCATIONS).setCacheControl(getCacheControl());
    }

    protected CacheControl getCacheControl() {
        return CacheControl.maxAge(getJHipsterHttpCacheProperty(), TimeUnit.DAYS).cachePublic();
    }

    private int getJHipsterHttpCacheProperty() {
        return jhipsterProperties.getHttp().getCache().getTimeToLiveInDays();
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/config/AsyncConfiguration.java
package ee.tenman.mmse.config;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;
import org.springframework.aop.interceptor.SimpleAsyncUncaughtExceptionHandler;
import org.springframework.boot.autoconfigure.task.TaskExecutionProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.scheduling.annotation.AsyncConfigurer;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
import tech.jhipster.async.ExceptionHandlingAsyncTaskExecutor;

import java.util.concurrent.Executor;

@Configuration
@EnableAsync
@EnableScheduling
@Profile("!testdev & !testprod")
public class AsyncConfiguration implements AsyncConfigurer {

    private final Logger log = LoggerFactory.getLogger(AsyncConfiguration.class);

    private final TaskExecutionProperties taskExecutionProperties;

    public AsyncConfiguration(TaskExecutionProperties taskExecutionProperties) {
        this.taskExecutionProperties = taskExecutionProperties;
    }

    @Override
    @Bean(name = "taskExecutor")
    public Executor getAsyncExecutor() {
        log.debug("Creating Async Task Executor");
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(taskExecutionProperties.getPool().getCoreSize());
        executor.setMaxPoolSize(taskExecutionProperties.getPool().getMaxSize());
        executor.setQueueCapacity(taskExecutionProperties.getPool().getQueueCapacity());
        executor.setThreadNamePrefix(taskExecutionProperties.getThreadNamePrefix());
        return new ExceptionHandlingAsyncTaskExecutor(executor);
    }

    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return new SimpleAsyncUncaughtExceptionHandler();
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/config/LoggingConfiguration.java
package ee.tenman.mmse.config;

import ch.qos.logback.classic.LoggerContext;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import tech.jhipster.config.JHipsterProperties;

import java.util.HashMap;
import java.util.Map;

import static tech.jhipster.config.logging.LoggingUtils.addContextListener;
import static tech.jhipster.config.logging.LoggingUtils.addJsonConsoleAppender;
import static tech.jhipster.config.logging.LoggingUtils.addLogstashTcpSocketAppender;

/*
 * Configures the console and Logstash log appenders from the app properties
 */
@Configuration
public class LoggingConfiguration {

    public LoggingConfiguration(
        @Value("${spring.application.name}") String appName,
        @Value("${server.port}") String serverPort,
        JHipsterProperties jHipsterProperties,
        ObjectMapper mapper
    ) throws JsonProcessingException {
        LoggerContext context = (LoggerContext) LoggerFactory.getILoggerFactory();

        Map<String, String> map = new HashMap<>();
        map.put("app_name", appName);
        map.put("app_port", serverPort);
        String customFields = mapper.writeValueAsString(map);

        JHipsterProperties.Logging loggingProperties = jHipsterProperties.getLogging();
        JHipsterProperties.Logging.Logstash logstashProperties = loggingProperties.getLogstash();

        if (loggingProperties.isUseJsonFormat()) {
            addJsonConsoleAppender(context, customFields);
        }
        if (logstashProperties.isEnabled()) {
            addLogstashTcpSocketAppender(context, customFields, logstashProperties);
        }
        if (loggingProperties.isUseJsonFormat() || logstashProperties.isEnabled()) {
            addContextListener(context, customFields, loggingProperties);
        }
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/config/LocaleConfiguration.java
package ee.tenman.mmse.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.LocaleResolver;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import org.springframework.web.servlet.i18n.LocaleChangeInterceptor;
import tech.jhipster.config.locale.AngularCookieLocaleResolver;

@Configuration
public class LocaleConfiguration implements WebMvcConfigurer {

    @Bean
    public LocaleResolver localeResolver() {
        AngularCookieLocaleResolver cookieLocaleResolver = new AngularCookieLocaleResolver();
        cookieLocaleResolver.setCookieName("NG_TRANSLATE_LANG_KEY");
        return cookieLocaleResolver;
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        LocaleChangeInterceptor localeChangeInterceptor = new LocaleChangeInterceptor();
        localeChangeInterceptor.setParamName("language");
        registry.addInterceptor(localeChangeInterceptor);
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/config/SecurityConfiguration.java
package ee.tenman.mmse.config;

import ee.tenman.mmse.security.AuthoritiesConstants;
import ee.tenman.mmse.web.filter.SpaWebFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configurers.HeadersConfigurer.FrameOptionsConfig;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.server.resource.web.BearerTokenAuthenticationEntryPoint;
import org.springframework.security.oauth2.server.resource.web.access.BearerTokenAccessDeniedHandler;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.www.BasicAuthenticationFilter;
import org.springframework.security.web.header.writers.ReferrerPolicyHeaderWriter;
import tech.jhipster.config.JHipsterProperties;

import static org.springframework.security.config.Customizer.withDefaults;

@Configuration
@EnableMethodSecurity(securedEnabled = true)
public class SecurityConfiguration {

    private final JHipsterProperties jHipsterProperties;

    public SecurityConfiguration(JHipsterProperties jHipsterProperties) {
        this.jHipsterProperties = jHipsterProperties;
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .cors(withDefaults())
            .csrf(csrf -> csrf.disable())
            .addFilterAfter(new SpaWebFilter(), BasicAuthenticationFilter.class)
            .headers(headers ->
                headers
                    .contentSecurityPolicy(csp -> csp.policyDirectives(jHipsterProperties.getSecurity().getContentSecurityPolicy()))
                    .frameOptions(FrameOptionsConfig::sameOrigin)
                    .referrerPolicy(referrer -> referrer.policy(ReferrerPolicyHeaderWriter.ReferrerPolicy.STRICT_ORIGIN_WHEN_CROSS_ORIGIN))
                    .permissionsPolicy(permissions ->
                        permissions.policy(
                            "camera=(), fullscreen=(self), geolocation=(), gyroscope=(), magnetometer=(), microphone=(), midi=(), payment=(), sync-xhr=()"
                        )
                    )
            )
            .authorizeHttpRequests(authz ->
                // prettier-ignore
                authz
                    .requestMatchers("/", "/index.html", "/*.js", "/*.map", "/*.css").permitAll()
                    .requestMatchers("/*.ico", "/*.png", "/*.svg", "/*.webapp").permitAll()
                    .requestMatchers("/app/**").permitAll()
                    .requestMatchers("/i18n/**").permitAll()
                    .requestMatchers("/content/**").permitAll()
                    .requestMatchers("/swagger-ui/**").permitAll()
                    .requestMatchers(HttpMethod.POST, "/api/authenticate").permitAll()
                    .requestMatchers(HttpMethod.GET, "/api/authenticate").permitAll()
                    .requestMatchers("/api/register").permitAll()
                    .requestMatchers("/api/activate").permitAll()
                    .requestMatchers("/api/account/reset-password/init").permitAll()
                    .requestMatchers("/api/account/reset-password/finish").permitAll()
                    .requestMatchers("/api/admin/**").hasAuthority(AuthoritiesConstants.ADMIN)
                    .requestMatchers("/api/**").authenticated()
                    .requestMatchers("/v3/api-docs/**").hasAuthority(AuthoritiesConstants.ADMIN)
                    .requestMatchers("/management/health").permitAll()
                    .requestMatchers("/management/health/**").permitAll()
                    .requestMatchers("/management/info").permitAll()
                    .requestMatchers("/management/prometheus").permitAll()
                    .requestMatchers("/management/**").hasAuthority(AuthoritiesConstants.ADMIN)
            )
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .exceptionHandling(exceptions ->
                exceptions
                    .authenticationEntryPoint(new BearerTokenAuthenticationEntryPoint())
                    .accessDeniedHandler(new BearerTokenAccessDeniedHandler())
            )
            .oauth2ResourceServer(oauth2 -> oauth2.jwt());
        return http.build();
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/config/JacksonConfiguration.java
package ee.tenman.mmse.config;

import com.fasterxml.jackson.datatype.hibernate6.Hibernate6Module;
import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class JacksonConfiguration {

    /**
     * Support for Java date and time API.
     *
     * @return the corresponding Jackson module.
     */
    @Bean
    public JavaTimeModule javaTimeModule() {
        return new JavaTimeModule();
    }

    @Bean
    public Jdk8Module jdk8TimeModule() {
        return new Jdk8Module();
    }

    /*
     * Support for Hibernate types in Jackson.
     */
    @Bean
    public Hibernate6Module hibernate6Module() {
        return new Hibernate6Module();
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/config/DatabaseConfiguration.java
package ee.tenman.mmse.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@Configuration
@EnableJpaRepositories({"ee.tenman.mmse.repository"})
@EnableJpaAuditing(auditorAwareRef = "springSecurityAuditorAware")
@EnableTransactionManagement
public class DatabaseConfiguration {
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/config/FilterConfig.java
package ee.tenman.mmse.config;

import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class FilterConfig {
    @Bean
    public FilterRegistrationBean<DebugFilter> loggingFilter() {
        FilterRegistrationBean<DebugFilter> registrationBean
            = new FilterRegistrationBean<>();

        registrationBean.setFilter(new DebugFilter());
        registrationBean.addUrlPatterns("/*");

        return registrationBean;
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/config/package-info.java
/**
 * Application configuration.
 */
package ee.tenman.mmse.config;


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/config/Constants.java
package ee.tenman.mmse.config;

/**
 * Application constants.
 */
public final class Constants {

    // Regex for acceptable logins
    public static final String LOGIN_REGEX = "^(?>[a-zA-Z0-9!$&*+=?^_`{|}~.-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*)|(?>[_.@A-Za-z0-9-]+)$";

    public static final String SYSTEM = "system";
    public static final String DEFAULT_LANGUAGE = "en";

    private Constants() {
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/config/CRLFLogConverter.java
package ee.tenman.mmse.config;

import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.pattern.CompositeConverter;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;
import org.springframework.boot.ansi.AnsiColor;
import org.springframework.boot.ansi.AnsiElement;
import org.springframework.boot.ansi.AnsiOutput;
import org.springframework.boot.ansi.AnsiStyle;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

/**
 * Log filter to prevent attackers from forging log entries by submitting input containing CRLF characters.
 * CRLF characters are replaced with a red colored _ character.
 *
 * @see <a href="https://owasp.org/www-community/attacks/Log_Injection">Log Forging Description</a>
 * @see <a href="https://github.com/jhipster/generator-jhipster/issues/14949">JHipster issue</a>
 */
public class CRLFLogConverter extends CompositeConverter<ILoggingEvent> {

    public static final Marker CRLF_SAFE_MARKER = MarkerFactory.getMarker("CRLF_SAFE");

    private static final String[] SAFE_LOGGERS = {
        "org.hibernate",
        "org.springframework.boot.autoconfigure",
        "org.springframework.boot.diagnostics",
    };
    private static final Map<String, AnsiElement> ELEMENTS;

    static {
        Map<String, AnsiElement> ansiElements = new HashMap<>();
        ansiElements.put("faint", AnsiStyle.FAINT);
        ansiElements.put("red", AnsiColor.RED);
        ansiElements.put("green", AnsiColor.GREEN);
        ansiElements.put("yellow", AnsiColor.YELLOW);
        ansiElements.put("blue", AnsiColor.BLUE);
        ansiElements.put("magenta", AnsiColor.MAGENTA);
        ansiElements.put("cyan", AnsiColor.CYAN);
        ELEMENTS = Collections.unmodifiableMap(ansiElements);
    }

    @Override
    protected String transform(ILoggingEvent event, String in) {
        AnsiElement element = ELEMENTS.get(getFirstOption());
        if ((event.getMarker() != null && event.getMarker().contains(CRLF_SAFE_MARKER)) || isLoggerSafe(event)) {
            return in;
        }
        String replacement = element == null ? "_" : toAnsiString("_", element);
        return in.replaceAll("[\n\r\t]", replacement);
    }

    protected boolean isLoggerSafe(ILoggingEvent event) {
        for (String safeLogger : SAFE_LOGGERS) {
            if (event.getLoggerName().startsWith(safeLogger)) {
                return true;
            }
        }
        return false;
    }

    protected String toAnsiString(String in, AnsiElement element) {
        return AnsiOutput.toString(element, in);
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/security/AuthoritiesConstants.java
package ee.tenman.mmse.security;

/**
 * Constants for Spring Security authorities.
 */
public final class AuthoritiesConstants {

    public static final String ADMIN = "ROLE_ADMIN";

    public static final String USER = "ROLE_USER";

    public static final String ANONYMOUS = "ROLE_ANONYMOUS";

    private AuthoritiesConstants() {
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/security/SecurityUtils.java
package ee.tenman.mmse.security;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.oauth2.jose.jws.MacAlgorithm;
import org.springframework.security.oauth2.jwt.Jwt;

import java.util.Arrays;
import java.util.Optional;
import java.util.stream.Stream;

/**
 * Utility class for Spring Security.
 */
public final class SecurityUtils {

    public static final MacAlgorithm JWT_ALGORITHM = MacAlgorithm.HS512;

    public static final String AUTHORITIES_KEY = "auth";

    private SecurityUtils() {
    }

    /**
     * Get the login of the current user.
     *
     * @return the login of the current user.
     */
    public static Optional<String> getCurrentUserLogin() {
        SecurityContext securityContext = SecurityContextHolder.getContext();
        return Optional.ofNullable(extractPrincipal(securityContext.getAuthentication()));
    }

    private static String extractPrincipal(Authentication authentication) {
        if (authentication == null) {
            return null;
        } else if (authentication.getPrincipal() instanceof UserDetails springSecurityUser) {
            return springSecurityUser.getUsername();
        } else if (authentication.getPrincipal() instanceof Jwt jwt) {
            return jwt.getSubject();
        } else if (authentication.getPrincipal() instanceof String s) {
            return s;
        }
        return null;
    }

    /**
     * Get the JWT of the current user.
     *
     * @return the JWT of the current user.
     */
    public static Optional<String> getCurrentUserJWT() {
        SecurityContext securityContext = SecurityContextHolder.getContext();
        return Optional
            .ofNullable(securityContext.getAuthentication())
            .filter(authentication -> authentication.getCredentials() instanceof String)
            .map(authentication -> (String) authentication.getCredentials());
    }

    /**
     * Check if a user is authenticated.
     *
     * @return true if the user is authenticated, false otherwise.
     */
    public static boolean isAuthenticated() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        return authentication != null && getAuthorities(authentication).noneMatch(AuthoritiesConstants.ANONYMOUS::equals);
    }

    /**
     * Checks if the current user has any of the authorities.
     *
     * @param authorities the authorities to check.
     * @return true if the current user has any of the authorities, false otherwise.
     */
    public static boolean hasCurrentUserAnyOfAuthorities(String... authorities) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        return (
            authentication != null && getAuthorities(authentication).anyMatch(authority -> Arrays.asList(authorities).contains(authority))
        );
    }

    /**
     * Checks if the current user has none of the authorities.
     *
     * @param authorities the authorities to check.
     * @return true if the current user has none of the authorities, false otherwise.
     */
    public static boolean hasCurrentUserNoneOfAuthorities(String... authorities) {
        return !hasCurrentUserAnyOfAuthorities(authorities);
    }

    /**
     * Checks if the current user has a specific authority.
     *
     * @param authority the authority to check.
     * @return true if the current user has the authority, false otherwise.
     */
    public static boolean hasCurrentUserThisAuthority(String authority) {
        return hasCurrentUserAnyOfAuthorities(authority);
    }

    private static Stream<String> getAuthorities(Authentication authentication) {
        return authentication.getAuthorities().stream().map(GrantedAuthority::getAuthority);
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/security/SpringSecurityAuditorAware.java
package ee.tenman.mmse.security;

import ee.tenman.mmse.config.Constants;
import org.springframework.data.domain.AuditorAware;
import org.springframework.stereotype.Component;

import java.util.Optional;

/**
 * Implementation of {@link AuditorAware} based on Spring Security.
 */
@Component
public class SpringSecurityAuditorAware implements AuditorAware<String> {

    @Override
    public Optional<String> getCurrentAuditor() {
        return Optional.of(SecurityUtils.getCurrentUserLogin().orElse(Constants.SYSTEM));
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/security/UserNotActivatedException.java
package ee.tenman.mmse.security;

import org.springframework.security.core.AuthenticationException;

/**
 * This exception is thrown in case of a not activated user trying to authenticate.
 */
public class UserNotActivatedException extends AuthenticationException {

    private static final long serialVersionUID = 1L;

    public UserNotActivatedException(String message) {
        super(message);
    }

    public UserNotActivatedException(String message, Throwable t) {
        super(message, t);
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/security/DomainUserDetailsService.java
package ee.tenman.mmse.security;

import ee.tenman.mmse.domain.Authority;
import ee.tenman.mmse.domain.User;
import ee.tenman.mmse.repository.UserRepository;
import org.hibernate.validator.internal.constraintvalidators.hv.EmailValidator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Locale;

/**
 * Authenticate a user from the database.
 */
@Component("userDetailsService")
public class DomainUserDetailsService implements UserDetailsService {

    private final Logger log = LoggerFactory.getLogger(DomainUserDetailsService.class);

    private final UserRepository userRepository;

    public DomainUserDetailsService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    @Transactional(readOnly = true)
    public UserDetails loadUserByUsername(final String login) {
        log.debug("Authenticating {}", login);

        if (new EmailValidator().isValid(login, null)) {
            return userRepository
                .findOneWithAuthoritiesByEmailIgnoreCase(login)
                .map(user -> createSpringSecurityUser(login, user))
                .orElseThrow(() -> new UsernameNotFoundException("User with email " + login + " was not found in the database"));
        }

        String lowercaseLogin = login.toLowerCase(Locale.ENGLISH);
        return userRepository
            .findOneWithAuthoritiesByLogin(lowercaseLogin)
            .map(user -> createSpringSecurityUser(lowercaseLogin, user))
            .orElseThrow(() -> new UsernameNotFoundException("User " + lowercaseLogin + " was not found in the database"));
    }

    private org.springframework.security.core.userdetails.User createSpringSecurityUser(String lowercaseLogin, User user) {
        if (!user.isActivated()) {
            throw new UserNotActivatedException("User " + lowercaseLogin + " was not activated");
        }
        List<SimpleGrantedAuthority> grantedAuthorities = user
            .getAuthorities()
            .stream()
            .map(Authority::getName)
            .map(SimpleGrantedAuthority::new)
            .toList();
        return new org.springframework.security.core.userdetails.User(user.getLogin(), user.getPassword(), grantedAuthorities);
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/security/package-info.java
/**
 * Application security utilities.
 */
package ee.tenman.mmse.security;


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/web/filter/SpaWebFilter.java
package ee.tenman.mmse.web.filter;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

public class SpaWebFilter extends OncePerRequestFilter {

    /**
     * Forwards any unmapped paths (except those containing a period) to the client {@code index.html}.
     */
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
        throws ServletException, IOException {
        String path = request.getRequestURI();
        if (
            !path.startsWith("/api") &&
                !path.startsWith("/management") &&
                !path.startsWith("/v3/api-docs") &&
                !path.contains(".") &&
                path.matches("/(.*)")
        ) {
            request.getRequestDispatcher("/index.html").forward(request, response);
            return;
        }

        filterChain.doFilter(request, response);
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/web/filter/package-info.java
/**
 * Request chain filters.
 */
package ee.tenman.mmse.web.filter;


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/web/rest/PublicUserResource.java
package ee.tenman.mmse.web.rest;

import ee.tenman.mmse.service.UserService;
import ee.tenman.mmse.service.dto.UserDTO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;
import tech.jhipster.web.util.PaginationUtil;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

@RestController
@RequestMapping("/api")
public class PublicUserResource {

    private static final List<String> ALLOWED_ORDERED_PROPERTIES = Collections.unmodifiableList(
        Arrays.asList("id", "login", "firstName", "lastName", "email", "activated", "langKey")
    );

    private final Logger log = LoggerFactory.getLogger(PublicUserResource.class);

    private final UserService userService;

    public PublicUserResource(UserService userService) {
        this.userService = userService;
    }

    /**
     * {@code GET /users} : get all users with only the public informations - calling this are allowed for anyone.
     *
     * @param pageable the pagination information.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body all users.
     */
    @GetMapping("/users")
    public ResponseEntity<List<UserDTO>> getAllPublicUsers(@org.springdoc.core.annotations.ParameterObject Pageable pageable) {
        log.debug("REST request to get all public User names");
        if (!onlyContainsAllowedProperties(pageable)) {
            return ResponseEntity.badRequest().build();
        }

        final Page<UserDTO> page = userService.getAllPublicUsers(pageable);
        HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(ServletUriComponentsBuilder.fromCurrentRequest(), page);
        return new ResponseEntity<>(page.getContent(), headers, HttpStatus.OK);
    }

    private boolean onlyContainsAllowedProperties(Pageable pageable) {
        return pageable.getSort().stream().map(Sort.Order::getProperty).allMatch(ALLOWED_ORDERED_PROPERTIES::contains);
    }

    /**
     * Gets a list of all roles.
     *
     * @return a string list of all roles.
     */
    @GetMapping("/authorities")
    public List<String> getAuthorities() {
        return userService.getAuthorities();
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/web/rest/AccountResource.java
package ee.tenman.mmse.web.rest;

import ee.tenman.mmse.domain.User;
import ee.tenman.mmse.repository.UserRepository;
import ee.tenman.mmse.security.SecurityUtils;
import ee.tenman.mmse.service.MailService;
import ee.tenman.mmse.service.UserService;
import ee.tenman.mmse.service.dto.AdminUserDTO;
import ee.tenman.mmse.service.dto.PasswordChangeDTO;
import ee.tenman.mmse.web.rest.errors.EmailAlreadyUsedException;
import ee.tenman.mmse.web.rest.errors.InvalidPasswordException;
import ee.tenman.mmse.web.rest.errors.LoginAlreadyUsedException;
import ee.tenman.mmse.web.rest.vm.KeyAndPasswordVM;
import ee.tenman.mmse.web.rest.vm.ManagedUserVM;
import jakarta.validation.Valid;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;

import java.util.Optional;

/**
 * REST controller for managing the current user's account.
 */
@RestController
@RequestMapping("/api")
public class AccountResource {

    private static class AccountResourceException extends RuntimeException {

        private AccountResourceException(String message) {
            super(message);
        }
    }

    private final Logger log = LoggerFactory.getLogger(AccountResource.class);

    private final UserRepository userRepository;

    private final UserService userService;

    private final MailService mailService;

    public AccountResource(UserRepository userRepository, UserService userService, MailService mailService) {
        this.userRepository = userRepository;
        this.userService = userService;
        this.mailService = mailService;
    }

    /**
     * {@code POST  /register} : register the user.
     *
     * @param managedUserVM the managed user View Model.
     * @throws InvalidPasswordException  {@code 400 (Bad Request)} if the password is incorrect.
     * @throws EmailAlreadyUsedException {@code 400 (Bad Request)} if the email is already used.
     * @throws LoginAlreadyUsedException {@code 400 (Bad Request)} if the login is already used.
     */
    @PostMapping("/register")
    @ResponseStatus(HttpStatus.CREATED)
    public void registerAccount(@Valid @RequestBody ManagedUserVM managedUserVM) {
        if (isPasswordLengthInvalid(managedUserVM.getPassword())) {
            throw new InvalidPasswordException();
        }
        User user = userService.registerUser(managedUserVM, managedUserVM.getPassword());
        mailService.sendActivationEmail(user);
    }

    /**
     * {@code GET  /activate} : activate the registered user.
     *
     * @param key the activation key.
     * @throws RuntimeException {@code 500 (Internal Server Error)} if the user couldn't be activated.
     */
    @GetMapping("/activate")
    public void activateAccount(@RequestParam(value = "key") String key) {
        Optional<User> user = userService.activateRegistration(key);
        if (!user.isPresent()) {
            throw new AccountResourceException("No user was found for this activation key");
        }
    }

    /**
     * {@code GET  /account} : get the current user.
     *
     * @return the current user.
     * @throws RuntimeException {@code 500 (Internal Server Error)} if the user couldn't be returned.
     */
    @GetMapping("/account")
    public AdminUserDTO getAccount() {
        return userService
            .findUserWithAuthorities()
            .map(AdminUserDTO::new)
            .orElseThrow(() -> new AccountResourceException("User could not be found"));
    }

    /**
     * {@code POST  /account} : update the current user information.
     *
     * @param userDTO the current user information.
     * @throws EmailAlreadyUsedException {@code 400 (Bad Request)} if the email is already used.
     * @throws RuntimeException          {@code 500 (Internal Server Error)} if the user login wasn't found.
     */
    @PostMapping("/account")
    public void saveAccount(@Valid @RequestBody AdminUserDTO userDTO) {
        String userLogin = SecurityUtils
            .getCurrentUserLogin()
            .orElseThrow(() -> new AccountResourceException("Current user login not found"));
        Optional<User> existingUser = userRepository.findOneByEmailIgnoreCase(userDTO.getEmail());
        if (existingUser.isPresent() && (!existingUser.orElseThrow().getLogin().equalsIgnoreCase(userLogin))) {
            throw new EmailAlreadyUsedException();
        }
        Optional<User> user = userRepository.findOneByLogin(userLogin);
        if (!user.isPresent()) {
            throw new AccountResourceException("User could not be found");
        }
        userService.updateUser(
            userDTO.getFirstName(),
            userDTO.getLastName(),
            userDTO.getEmail(),
            userDTO.getLangKey(),
            userDTO.getImageUrl()
        );
    }

    /**
     * {@code POST  /account/change-password} : changes the current user's password.
     *
     * @param passwordChangeDto current and new password.
     * @throws InvalidPasswordException {@code 400 (Bad Request)} if the new password is incorrect.
     */
    @PostMapping(path = "/account/change-password")
    public void changePassword(@RequestBody PasswordChangeDTO passwordChangeDto) {
        if (isPasswordLengthInvalid(passwordChangeDto.getNewPassword())) {
            throw new InvalidPasswordException();
        }
        userService.changePassword(passwordChangeDto.getCurrentPassword(), passwordChangeDto.getNewPassword());
    }

    /**
     * {@code POST   /account/reset-password/init} : Send an email to reset the password of the user.
     *
     * @param mail the mail of the user.
     */
    @PostMapping(path = "/account/reset-password/init")
    public void requestPasswordReset(@RequestBody String mail) {
        Optional<User> user = userService.requestPasswordReset(mail);
        if (user.isPresent()) {
            mailService.sendPasswordResetMail(user.orElseThrow());
        } else {
            // Pretend the request has been successful to prevent checking which emails really exist
            // but log that an invalid attempt has been made
            log.warn("Password reset requested for non existing mail");
        }
    }

    /**
     * {@code POST   /account/reset-password/finish} : Finish to reset the password of the user.
     *
     * @param keyAndPassword the generated key and the new password.
     * @throws InvalidPasswordException {@code 400 (Bad Request)} if the password is incorrect.
     * @throws RuntimeException         {@code 500 (Internal Server Error)} if the password could not be reset.
     */
    @PostMapping(path = "/account/reset-password/finish")
    public void finishPasswordReset(@RequestBody KeyAndPasswordVM keyAndPassword) {
        if (isPasswordLengthInvalid(keyAndPassword.getNewPassword())) {
            throw new InvalidPasswordException();
        }
        Optional<User> user = userService.completePasswordReset(keyAndPassword.getNewPassword(), keyAndPassword.getKey());

        if (!user.isPresent()) {
            throw new AccountResourceException("No user was found for this reset key");
        }
    }

    private static boolean isPasswordLengthInvalid(String password) {
        return (
            StringUtils.isEmpty(password) ||
                password.length() < ManagedUserVM.PASSWORD_MIN_LENGTH ||
                password.length() > ManagedUserVM.PASSWORD_MAX_LENGTH
        );
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/web/rest/TestEntityResource.java
package ee.tenman.mmse.web.rest;

import ee.tenman.mmse.repository.TestEntityRepository;
import ee.tenman.mmse.service.TestEntityService;
import ee.tenman.mmse.service.dto.TestEntityDTO;
import ee.tenman.mmse.web.rest.errors.BadRequestAlertException;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;
import tech.jhipster.web.util.HeaderUtil;
import tech.jhipster.web.util.PaginationUtil;
import tech.jhipster.web.util.ResponseUtil;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

/**
 * REST controller for managing {@link ee.tenman.mmse.domain.TestEntity}.
 */
@RestController
@RequestMapping("/api")
public class TestEntityResource {

    private final Logger log = LoggerFactory.getLogger(TestEntityResource.class);

    private static final String ENTITY_NAME = "testEntity";

    @Value("${jhipster.clientApp.name}")
    private String applicationName;

    private final TestEntityService testEntityService;

    private final TestEntityRepository testEntityRepository;

    public TestEntityResource(TestEntityService testEntityService, TestEntityRepository testEntityRepository) {
        this.testEntityService = testEntityService;
        this.testEntityRepository = testEntityRepository;
    }

    /**
     * {@code POST  /test-entities} : Create a new testEntity.
     *
     * @param testEntityDTO the testEntityDTO to create.
     * @return the {@link ResponseEntity} with status {@code 201 (Created)} and with body the new testEntityDTO, or with status {@code 400 (Bad Request)} if the testEntity has already an ID.
     * @throws URISyntaxException if the Location URI syntax is incorrect.
     */
    @PostMapping("/test-entities")
    public ResponseEntity<TestEntityDTO> createTestEntity(@Valid @RequestBody TestEntityDTO testEntityDTO) throws URISyntaxException {
        log.debug("REST request to save TestEntity : {}", testEntityDTO);
        if (testEntityDTO.getId() != null) {
            throw new BadRequestAlertException("A new testEntity cannot already have an ID", ENTITY_NAME, "idexists");
        }
        TestEntityDTO result = testEntityService.save(testEntityDTO);
        return ResponseEntity
            .created(new URI("/api/test-entities/" + result.getId()))
            .headers(HeaderUtil.createEntityCreationAlert(applicationName, true, ENTITY_NAME, result.getId().toString()))
            .body(result);
    }

    /**
     * {@code PUT  /test-entities/:id} : Updates an existing testEntity.
     *
     * @param id            the id of the testEntityDTO to save.
     * @param testEntityDTO the testEntityDTO to update.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the updated testEntityDTO,
     * or with status {@code 400 (Bad Request)} if the testEntityDTO is not valid,
     * or with status {@code 500 (Internal Server Error)} if the testEntityDTO couldn't be updated.
     * @throws URISyntaxException if the Location URI syntax is incorrect.
     */
    @PutMapping("/test-entities/{id}")
    public ResponseEntity<TestEntityDTO> updateTestEntity(
        @PathVariable(value = "id", required = false) final Long id,
        @Valid @RequestBody TestEntityDTO testEntityDTO
    ) throws URISyntaxException {
        log.debug("REST request to update TestEntity : {}, {}", id, testEntityDTO);
        if (testEntityDTO.getId() == null) {
            throw new BadRequestAlertException("Invalid id", ENTITY_NAME, "idnull");
        }
        if (!Objects.equals(id, testEntityDTO.getId())) {
            throw new BadRequestAlertException("Invalid ID", ENTITY_NAME, "idinvalid");
        }

        if (!testEntityRepository.existsById(id)) {
            throw new BadRequestAlertException("Entity not found", ENTITY_NAME, "idnotfound");
        }

        TestEntityDTO result = testEntityService.update(testEntityDTO);
        return ResponseEntity
            .ok()
            .headers(HeaderUtil.createEntityUpdateAlert(applicationName, true, ENTITY_NAME, testEntityDTO.getId().toString()))
            .body(result);
    }

    /**
     * {@code PATCH  /test-entities/:id} : Partial updates given fields of an existing testEntity, field will ignore if it is null
     *
     * @param id            the id of the testEntityDTO to save.
     * @param testEntityDTO the testEntityDTO to update.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the updated testEntityDTO,
     * or with status {@code 400 (Bad Request)} if the testEntityDTO is not valid,
     * or with status {@code 404 (Not Found)} if the testEntityDTO is not found,
     * or with status {@code 500 (Internal Server Error)} if the testEntityDTO couldn't be updated.
     * @throws URISyntaxException if the Location URI syntax is incorrect.
     */
    @PatchMapping(value = "/test-entities/{id}", consumes = {"application/json", "application/merge-patch+json"})
    public ResponseEntity<TestEntityDTO> partialUpdateTestEntity(
        @PathVariable(value = "id", required = false) final Long id,
        @NotNull @RequestBody TestEntityDTO testEntityDTO
    ) throws URISyntaxException {
        log.debug("REST request to partial update TestEntity partially : {}, {}", id, testEntityDTO);
        if (testEntityDTO.getId() == null) {
            throw new BadRequestAlertException("Invalid id", ENTITY_NAME, "idnull");
        }
        if (!Objects.equals(id, testEntityDTO.getId())) {
            throw new BadRequestAlertException("Invalid ID", ENTITY_NAME, "idinvalid");
        }

        if (!testEntityRepository.existsById(id)) {
            throw new BadRequestAlertException("Entity not found", ENTITY_NAME, "idnotfound");
        }

        Optional<TestEntityDTO> result = testEntityService.partialUpdate(testEntityDTO);

        return ResponseUtil.wrapOrNotFound(
            result,
            HeaderUtil.createEntityUpdateAlert(applicationName, true, ENTITY_NAME, testEntityDTO.getId().toString())
        );
    }

    /**
     * {@code GET  /test-entities} : get all the testEntities.
     *
     * @param pageable  the pagination information.
     * @param eagerload flag to eager load entities from relationships (This is applicable for many-to-many).
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and the list of testEntities in body.
     */
    @GetMapping("/test-entities")
    public ResponseEntity<List<TestEntityDTO>> getAllTestEntities(
        @org.springdoc.core.annotations.ParameterObject Pageable pageable,
        @RequestParam(required = false, defaultValue = "false") boolean eagerload
    ) {
        log.debug("REST request to get a page of TestEntities");
        Page<TestEntityDTO> page;
        if (eagerload) {
            page = testEntityService.findAllWithEagerRelationships(pageable);
        } else {
            page = testEntityService.findAll(pageable);
        }
        HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(ServletUriComponentsBuilder.fromCurrentRequest(), page);
        return ResponseEntity.ok().headers(headers).body(page.getContent());
    }

    /**
     * {@code GET  /test-entities/:id} : get the "id" testEntity.
     *
     * @param id the id of the testEntityDTO to retrieve.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the testEntityDTO, or with status {@code 404 (Not Found)}.
     */
    @GetMapping("/test-entities/{id}")
    public ResponseEntity<TestEntityDTO> getTestEntity(@PathVariable Long id) {
        log.debug("REST request to get TestEntity : {}", id);
        Optional<TestEntityDTO> testEntityDTO = testEntityService.findOne(id);
        return ResponseUtil.wrapOrNotFound(testEntityDTO);
    }

    /**
     * {@code DELETE  /test-entities/:id} : delete the "id" testEntity.
     *
     * @param id the id of the testEntityDTO to delete.
     * @return the {@link ResponseEntity} with status {@code 204 (NO_CONTENT)}.
     */
    @DeleteMapping("/test-entities/{id}")
    public ResponseEntity<Void> deleteTestEntity(@PathVariable Long id) {
        log.debug("REST request to delete TestEntity : {}", id);
        testEntityService.delete(id);
        return ResponseEntity
            .noContent()
            .headers(HeaderUtil.createEntityDeletionAlert(applicationName, true, ENTITY_NAME, id.toString()))
            .build();
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/web/rest/UserResource.java
package ee.tenman.mmse.web.rest;

import ee.tenman.mmse.config.Constants;
import ee.tenman.mmse.domain.User;
import ee.tenman.mmse.repository.UserRepository;
import ee.tenman.mmse.security.AuthoritiesConstants;
import ee.tenman.mmse.service.MailService;
import ee.tenman.mmse.service.UserService;
import ee.tenman.mmse.service.dto.AdminUserDTO;
import ee.tenman.mmse.web.rest.errors.BadRequestAlertException;
import ee.tenman.mmse.web.rest.errors.EmailAlreadyUsedException;
import ee.tenman.mmse.web.rest.errors.LoginAlreadyUsedException;
import jakarta.validation.Valid;
import jakarta.validation.constraints.Pattern;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;
import tech.jhipster.web.util.HeaderUtil;
import tech.jhipster.web.util.PaginationUtil;
import tech.jhipster.web.util.ResponseUtil;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

/**
 * REST controller for managing users.
 * <p>
 * This class accesses the {@link ee.tenman.mmse.domain.User} entity, and needs to fetch its collection of authorities.
 * <p>
 * For a normal use-case, it would be better to have an eager relationship between User and Authority,
 * and send everything to the client side: there would be no View Model and DTO, a lot less code, and an outer-join
 * which would be good for performance.
 * <p>
 * We use a View Model and a DTO for 3 reasons:
 * <ul>
 * <li>We want to keep a lazy association between the user and the authorities, because people will
 * quite often do relationships with the user, and we don't want them to get the authorities all
 * the time for nothing (for performance reasons). This is the #1 goal: we should not impact our users'
 * application because of this use-case.</li>
 * <li> Not having an outer join causes n+1 requests to the database. This is not a real issue as
 * we have by default a second-level cache. This means on the first HTTP call we do the n+1 requests,
 * but then all authorities come from the cache, so in fact it's much better than doing an outer join
 * (which will get lots of data from the database, for each HTTP call).</li>
 * <li> As this manages users, for security reasons, we'd rather have a DTO layer.</li>
 * </ul>
 * <p>
 * Another option would be to have a specific JPA entity graph to handle this case.
 */
@RestController
@RequestMapping("/api/admin")
public class UserResource {

    private static final List<String> ALLOWED_ORDERED_PROPERTIES = Collections.unmodifiableList(
        Arrays.asList(
            "id",
            "login",
            "firstName",
            "lastName",
            "email",
            "activated",
            "langKey",
            "createdBy",
            "createdDate",
            "lastModifiedBy",
            "lastModifiedDate"
        )
    );

    private final Logger log = LoggerFactory.getLogger(UserResource.class);

    @Value("${jhipster.clientApp.name}")
    private String applicationName;

    private final UserService userService;

    private final UserRepository userRepository;

    private final MailService mailService;

    public UserResource(UserService userService, UserRepository userRepository, MailService mailService) {
        this.userService = userService;
        this.userRepository = userRepository;
        this.mailService = mailService;
    }

    /**
     * {@code POST  /admin/users}  : Creates a new user.
     * <p>
     * Creates a new user if the login and email are not already used, and sends an
     * mail with an activation link.
     * The user needs to be activated on creation.
     *
     * @param userDTO the user to create.
     * @return the {@link ResponseEntity} with status {@code 201 (Created)} and with body the new user, or with status {@code 400 (Bad Request)} if the login or email is already in use.
     * @throws URISyntaxException       if the Location URI syntax is incorrect.
     * @throws BadRequestAlertException {@code 400 (Bad Request)} if the login or email is already in use.
     */
    @PostMapping("/users")
    @PreAuthorize("hasAuthority(\"" + AuthoritiesConstants.ADMIN + "\")")
    public ResponseEntity<User> createUser(@Valid @RequestBody AdminUserDTO userDTO) throws URISyntaxException {
        log.debug("REST request to save User : {}", userDTO);

        if (userDTO.getId() != null) {
            throw new BadRequestAlertException("A new user cannot already have an ID", "userManagement", "idexists");
            // Lowercase the user login before comparing with database
        } else if (userRepository.findOneByLogin(userDTO.getLogin().toLowerCase()).isPresent()) {
            throw new LoginAlreadyUsedException();
        } else if (userRepository.findOneByEmailIgnoreCase(userDTO.getEmail()).isPresent()) {
            throw new EmailAlreadyUsedException();
        } else {
            User newUser = userService.createUser(userDTO);
            mailService.sendCreationEmail(newUser);
            return ResponseEntity
                .created(new URI("/api/admin/users/" + newUser.getLogin()))
                .headers(HeaderUtil.createAlert(applicationName, "userManagement.created", newUser.getLogin()))
                .body(newUser);
        }
    }

    /**
     * {@code PUT /admin/users} : Updates an existing User.
     *
     * @param userDTO the user to update.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the updated user.
     * @throws EmailAlreadyUsedException {@code 400 (Bad Request)} if the email is already in use.
     * @throws LoginAlreadyUsedException {@code 400 (Bad Request)} if the login is already in use.
     */
    @PutMapping("/users")
    @PreAuthorize("hasAuthority(\"" + AuthoritiesConstants.ADMIN + "\")")
    public ResponseEntity<AdminUserDTO> updateUser(@Valid @RequestBody AdminUserDTO userDTO) {
        log.debug("REST request to update User : {}", userDTO);
        Optional<User> existingUser = userRepository.findOneByEmailIgnoreCase(userDTO.getEmail());
        if (existingUser.isPresent() && (!existingUser.orElseThrow().getId().equals(userDTO.getId()))) {
            throw new EmailAlreadyUsedException();
        }
        existingUser = userRepository.findOneByLogin(userDTO.getLogin().toLowerCase());
        if (existingUser.isPresent() && (!existingUser.orElseThrow().getId().equals(userDTO.getId()))) {
            throw new LoginAlreadyUsedException();
        }
        Optional<AdminUserDTO> updatedUser = userService.updateUser(userDTO);

        return ResponseUtil.wrapOrNotFound(
            updatedUser,
            HeaderUtil.createAlert(applicationName, "userManagement.updated", userDTO.getLogin())
        );
    }

    /**
     * {@code GET /admin/users} : get all users with all the details - calling this are only allowed for the administrators.
     *
     * @param pageable the pagination information.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body all users.
     */
    @GetMapping("/users")
    @PreAuthorize("hasAuthority(\"" + AuthoritiesConstants.ADMIN + "\")")
    public ResponseEntity<List<AdminUserDTO>> getAllUsers(@org.springdoc.core.annotations.ParameterObject Pageable pageable) {
        log.debug("REST request to get all User for an admin");
        if (!onlyContainsAllowedProperties(pageable)) {
            return ResponseEntity.badRequest().build();
        }

        final Page<AdminUserDTO> page = userService.getAllManagedUsers(pageable);
        HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(ServletUriComponentsBuilder.fromCurrentRequest(), page);
        return new ResponseEntity<>(page.getContent(), headers, HttpStatus.OK);
    }

    private boolean onlyContainsAllowedProperties(Pageable pageable) {
        return pageable.getSort().stream().map(Sort.Order::getProperty).allMatch(ALLOWED_ORDERED_PROPERTIES::contains);
    }

    /**
     * {@code GET /admin/users/:login} : get the "login" user.
     *
     * @param login the login of the user to find.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the "login" user, or with status {@code 404 (Not Found)}.
     */
    @GetMapping("/users/{login}")
    @PreAuthorize("hasAuthority(\"" + AuthoritiesConstants.ADMIN + "\")")
    public ResponseEntity<AdminUserDTO> getUser(@PathVariable @Pattern(regexp = Constants.LOGIN_REGEX) String login) {
        log.debug("REST request to get User : {}", login);
        return ResponseUtil.wrapOrNotFound(userService.getUserWithAuthoritiesByLogin(login).map(AdminUserDTO::new));
    }

    /**
     * {@code DELETE /admin/users/:login} : delete the "login" User.
     *
     * @param login the login of the user to delete.
     * @return the {@link ResponseEntity} with status {@code 204 (NO_CONTENT)}.
     */
    @DeleteMapping("/users/{login}")
    @PreAuthorize("hasAuthority(\"" + AuthoritiesConstants.ADMIN + "\")")
    public ResponseEntity<Void> deleteUser(@PathVariable @Pattern(regexp = Constants.LOGIN_REGEX) String login) {
        log.debug("REST request to delete User: {}", login);
        userService.deleteUser(login);
        return ResponseEntity.noContent().headers(HeaderUtil.createAlert(applicationName, "userManagement.deleted", login)).build();
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/web/rest/UserAnswerResource.java
package ee.tenman.mmse.web.rest;

import ee.tenman.mmse.repository.UserAnswerRepository;
import ee.tenman.mmse.service.UserAnswerService;
import ee.tenman.mmse.service.dto.UserAnswerDTO;
import ee.tenman.mmse.web.rest.errors.BadRequestAlertException;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;
import tech.jhipster.web.util.HeaderUtil;
import tech.jhipster.web.util.PaginationUtil;
import tech.jhipster.web.util.ResponseUtil;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

/**
 * REST controller for managing {@link ee.tenman.mmse.domain.UserAnswer}.
 */
@RestController
@RequestMapping("/api")
public class UserAnswerResource {

    private final Logger log = LoggerFactory.getLogger(UserAnswerResource.class);

    private static final String ENTITY_NAME = "userAnswer";

    @Value("${jhipster.clientApp.name}")
    private String applicationName;

    private final UserAnswerService userAnswerService;

    private final UserAnswerRepository userAnswerRepository;

    public UserAnswerResource(UserAnswerService userAnswerService, UserAnswerRepository userAnswerRepository) {
        this.userAnswerService = userAnswerService;
        this.userAnswerRepository = userAnswerRepository;
    }

    /**
     * {@code POST  /user-answers} : Create a new userAnswer.
     *
     * @param userAnswerDTO the userAnswerDTO to create.
     * @return the {@link ResponseEntity} with status {@code 201 (Created)} and with body the new userAnswerDTO, or with status {@code 400 (Bad Request)} if the userAnswer has already an ID.
     * @throws URISyntaxException if the Location URI syntax is incorrect.
     */
    @PostMapping("/user-answers")
    public ResponseEntity<UserAnswerDTO> createUserAnswer(@Valid @RequestBody UserAnswerDTO userAnswerDTO) throws URISyntaxException {
        log.debug("REST request to save UserAnswer : {}", userAnswerDTO);
        if (userAnswerDTO.getId() != null) {
            throw new BadRequestAlertException("A new userAnswer cannot already have an ID", ENTITY_NAME, "idexists");
        }
        UserAnswerDTO result = userAnswerService.save(userAnswerDTO);
        return ResponseEntity
            .created(new URI("/api/user-answers/" + result.getId()))
            .headers(HeaderUtil.createEntityCreationAlert(applicationName, true, ENTITY_NAME, result.getId().toString()))
            .body(result);
    }

    /**
     * {@code PUT  /user-answers/:id} : Updates an existing userAnswer.
     *
     * @param id            the id of the userAnswerDTO to save.
     * @param userAnswerDTO the userAnswerDTO to update.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the updated userAnswerDTO,
     * or with status {@code 400 (Bad Request)} if the userAnswerDTO is not valid,
     * or with status {@code 500 (Internal Server Error)} if the userAnswerDTO couldn't be updated.
     * @throws URISyntaxException if the Location URI syntax is incorrect.
     */
    @PutMapping("/user-answers/{id}")
    public ResponseEntity<UserAnswerDTO> updateUserAnswer(
        @PathVariable(value = "id", required = false) final Long id,
        @Valid @RequestBody UserAnswerDTO userAnswerDTO
    ) throws URISyntaxException {
        log.debug("REST request to update UserAnswer : {}, {}", id, userAnswerDTO);
        if (userAnswerDTO.getId() == null) {
            throw new BadRequestAlertException("Invalid id", ENTITY_NAME, "idnull");
        }
        if (!Objects.equals(id, userAnswerDTO.getId())) {
            throw new BadRequestAlertException("Invalid ID", ENTITY_NAME, "idinvalid");
        }

        if (!userAnswerRepository.existsById(id)) {
            throw new BadRequestAlertException("Entity not found", ENTITY_NAME, "idnotfound");
        }

        UserAnswerDTO result = userAnswerService.update(userAnswerDTO);
        return ResponseEntity
            .ok()
            .headers(HeaderUtil.createEntityUpdateAlert(applicationName, true, ENTITY_NAME, userAnswerDTO.getId().toString()))
            .body(result);
    }

    /**
     * {@code PATCH  /user-answers/:id} : Partial updates given fields of an existing userAnswer, field will ignore if it is null
     *
     * @param id            the id of the userAnswerDTO to save.
     * @param userAnswerDTO the userAnswerDTO to update.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the updated userAnswerDTO,
     * or with status {@code 400 (Bad Request)} if the userAnswerDTO is not valid,
     * or with status {@code 404 (Not Found)} if the userAnswerDTO is not found,
     * or with status {@code 500 (Internal Server Error)} if the userAnswerDTO couldn't be updated.
     * @throws URISyntaxException if the Location URI syntax is incorrect.
     */
    @PatchMapping(value = "/user-answers/{id}", consumes = {"application/json", "application/merge-patch+json"})
    public ResponseEntity<UserAnswerDTO> partialUpdateUserAnswer(
        @PathVariable(value = "id", required = false) final Long id,
        @NotNull @RequestBody UserAnswerDTO userAnswerDTO
    ) throws URISyntaxException {
        log.debug("REST request to partial update UserAnswer partially : {}, {}", id, userAnswerDTO);
        if (userAnswerDTO.getId() == null) {
            throw new BadRequestAlertException("Invalid id", ENTITY_NAME, "idnull");
        }
        if (!Objects.equals(id, userAnswerDTO.getId())) {
            throw new BadRequestAlertException("Invalid ID", ENTITY_NAME, "idinvalid");
        }

        if (!userAnswerRepository.existsById(id)) {
            throw new BadRequestAlertException("Entity not found", ENTITY_NAME, "idnotfound");
        }

        Optional<UserAnswerDTO> result = userAnswerService.partialUpdate(userAnswerDTO);

        return ResponseUtil.wrapOrNotFound(
            result,
            HeaderUtil.createEntityUpdateAlert(applicationName, true, ENTITY_NAME, userAnswerDTO.getId().toString())
        );
    }

    /**
     * {@code GET  /user-answers} : get all the userAnswers.
     *
     * @param pageable the pagination information.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and the list of userAnswers in body.
     */
    @GetMapping("/user-answers")
    public ResponseEntity<List<UserAnswerDTO>> getAllUserAnswers(@org.springdoc.core.annotations.ParameterObject Pageable pageable) {
        log.debug("REST request to get a page of UserAnswers");
        Page<UserAnswerDTO> page = userAnswerService.findAll(pageable);
        HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(ServletUriComponentsBuilder.fromCurrentRequest(), page);
        return ResponseEntity.ok().headers(headers).body(page.getContent());
    }

    /**
     * {@code GET  /user-answers/:id} : get the "id" userAnswer.
     *
     * @param id the id of the userAnswerDTO to retrieve.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the userAnswerDTO, or with status {@code 404 (Not Found)}.
     */
    @GetMapping("/user-answers/{id}")
    public ResponseEntity<UserAnswerDTO> getUserAnswer(@PathVariable Long id) {
        log.debug("REST request to get UserAnswer : {}", id);
        Optional<UserAnswerDTO> userAnswerDTO = userAnswerService.findOne(id);
        return ResponseUtil.wrapOrNotFound(userAnswerDTO);
    }

    /**
     * {@code DELETE  /user-answers/:id} : delete the "id" userAnswer.
     *
     * @param id the id of the userAnswerDTO to delete.
     * @return the {@link ResponseEntity} with status {@code 204 (NO_CONTENT)}.
     */
    @DeleteMapping("/user-answers/{id}")
    public ResponseEntity<Void> deleteUserAnswer(@PathVariable Long id) {
        log.debug("REST request to delete UserAnswer : {}", id);
        userAnswerService.delete(id);
        return ResponseEntity
            .noContent()
            .headers(HeaderUtil.createEntityDeletionAlert(applicationName, true, ENTITY_NAME, id.toString()))
            .build();
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/web/rest/QuizController.java
package ee.tenman.mmse.web.rest;

import ee.tenman.mmse.domain.MediaRecording;
import ee.tenman.mmse.domain.TestEntity;
import ee.tenman.mmse.domain.User;
import ee.tenman.mmse.domain.UserAnswer;
import ee.tenman.mmse.domain.enumeration.QuestionId;
import ee.tenman.mmse.repository.MediaRecordingRepository;
import ee.tenman.mmse.repository.TestEntityRepository;
import ee.tenman.mmse.service.UserAnswerService;
import ee.tenman.mmse.service.UserService;
import ee.tenman.mmse.service.dto.AnswerDTO;
import ee.tenman.mmse.service.external.minio.StorageService;
import ee.tenman.mmse.service.question.Question;
import ee.tenman.mmse.service.question.QuizService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ContentDisposition;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.UUID;

@RestController
@RequestMapping("/api")
public class QuizController {

    private final QuizService quizService;
    private final UserAnswerService userAnswerService;
    private final TestEntityRepository testEntityRepository;
    private final UserService userService;
    private final StorageService storageService;
    private final MediaRecordingRepository mediaRecordingRepository;

    @Autowired
    public QuizController(QuizService quizService, UserAnswerService userAnswerService, TestEntityRepository testEntityRepository, UserService userService, StorageService storageService, MediaRecordingRepository mediaRecordingRepository) {
        this.quizService = quizService;
        this.userAnswerService = userAnswerService;
        this.testEntityRepository = testEntityRepository;
        this.userService = userService;
        this.storageService = storageService;
        this.mediaRecordingRepository = mediaRecordingRepository;
    }

    @GetMapping("/question")
    public ResponseEntity<?> getNextQuestion() {
        Optional<UserAnswer> latestUserAnswer = userAnswerService.getLatest();
        if (latestUserAnswer.isPresent()) {
            Optional<QuestionId> nextQuestionId = getNextQuestionId(latestUserAnswer.get().getQuestionId());
            return handleNextQuestion(nextQuestionId);
        } else {
            // If there's no latest user answer, this means the quiz has just started. Return the first question.
            Question firstQuestion = quizService.getFirstQuestion();
            return ResponseEntity.ok(firstQuestion);
        }
    }

    @PostMapping("/answer")
    @ResponseStatus(HttpStatus.CREATED)
    public void saveAnswer(@RequestBody @Valid AnswerDTO answerDTO) {
        quizService.saveAnswer(answerDTO);
    }

    @PostMapping("/retake")
    public Question retakeTest() {
        return quizService.retakeTest();
    }

    @GetMapping("/last-recorded-audio")
    public ResponseEntity<byte[]> getLastRecordedAudio(@RequestParam("questionId") QuestionId questionId) {
        User user = userService.getUserWithAuthorities();
        TestEntity testEntity = testEntityRepository.findFirstByUserIdOrderByCreatedAtDesc(user.getId()).orElseThrow(() -> new NoSuchElementException("Test not found"));

        MediaRecording mediaRecording = mediaRecordingRepository.findFirstByTestEntityIdAndQuestionIdOrderByCreatedAtDesc(testEntity.getId(), questionId)
            .orElseThrow(() -> new NoSuchElementException("No media recording found"));

        String fileName = mediaRecording.getFileName();
        byte[] audioData = storageService.downloadFile(fileName);

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
        headers.setContentDisposition(ContentDisposition.attachment().filename(fileName).build());

        return new ResponseEntity<>(audioData, headers, HttpStatus.OK);
    }

    @PostMapping("/upload-audio")
    public ResponseEntity<?> uploadAudio(@RequestParam("audio") MultipartFile audioFile, @RequestParam("questionId") QuestionId questionId) {
        User user = userService.getUserWithAuthorities();
        TestEntity testEntity = testEntityRepository.findFirstByUserIdOrderByCreatedAtDesc(user.getId()).orElseThrow(() -> new NoSuchElementException("Test not found"));

        UUID fileUuid = UUID.randomUUID();
        String fileName = fileUuid + "." + getFileExtension(audioFile.getOriginalFilename());

        storageService.uploadFile(audioFile, fileName);

        MediaRecording mediaRecording = new MediaRecording();
        mediaRecording.setFileName(fileName);
        mediaRecording.setTestEntity(testEntity);
        mediaRecording.setQuestionId(questionId);
        mediaRecordingRepository.save(mediaRecording);

        return ResponseEntity.ok(Map.of("fileName", fileName));
    }

    private String getFileExtension(String fileName) {
        if (fileName == null || fileName.isEmpty()) {
            return "";
        }
        int dotIndex = fileName.lastIndexOf('.');
        if (dotIndex > 0 && dotIndex < fileName.length() - 1) {
            return fileName.substring(dotIndex + 1);
        }
        return "";
    }

    private Optional<QuestionId> getNextQuestionId(QuestionId currentQuestionId) {
        QuestionId[] questionIds = QuestionId.values();
        int nextQuestionIndex = currentQuestionId.ordinal() + 1;

        if (nextQuestionIndex < questionIds.length) {
            return Optional.of(questionIds[nextQuestionIndex]);
        }

        return Optional.empty();
    }

    private ResponseEntity<?> handleNextQuestion(Optional<QuestionId> nextQuestionId) {
        if (nextQuestionId.isEmpty()) {
            User user = userService.getUserWithAuthorities();
            TestEntity testEntity = testEntityRepository.findFirstByUserIdOrderByCreatedAtDesc(user.getId()).orElseThrow(() -> new NoSuchElementException("Test not found"));
            int calculateScore = quizService.calculateScore(testEntity.getId());
            testEntity.setScore(calculateScore);
            testEntityRepository.save(testEntity);

            // Return a response indicating that the quiz has ended.
            return ResponseEntity.ok().body("Quiz has ended. Your score is " + calculateScore);
        }

        // Continue the quiz with the next question
        Question nextQuestion = quizService.getQuestion(nextQuestionId.get());
        return ResponseEntity.ok(nextQuestion);
    }

}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/web/rest/AuthenticateController.java
package ee.tenman.mmse.web.rest;

import com.fasterxml.jackson.annotation.JsonProperty;
import ee.tenman.mmse.web.rest.vm.LoginVM;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.oauth2.jwt.JwsHeader;
import org.springframework.security.oauth2.jwt.JwtClaimsSet;
import org.springframework.security.oauth2.jwt.JwtEncoder;
import org.springframework.security.oauth2.jwt.JwtEncoderParameters;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.stream.Collectors;

import static ee.tenman.mmse.security.SecurityUtils.AUTHORITIES_KEY;
import static ee.tenman.mmse.security.SecurityUtils.JWT_ALGORITHM;

/**
 * Controller to authenticate users.
 */
@RestController
@RequestMapping("/api")
public class AuthenticateController {

    private final Logger log = LoggerFactory.getLogger(AuthenticateController.class);

    private final JwtEncoder jwtEncoder;

    @Value("${jhipster.security.authentication.jwt.token-validity-in-seconds:0}")
    private long tokenValidityInSeconds;

    @Value("${jhipster.security.authentication.jwt.token-validity-in-seconds-for-remember-me:0}")
    private long tokenValidityInSecondsForRememberMe;

    private final AuthenticationManagerBuilder authenticationManagerBuilder;

    public AuthenticateController(JwtEncoder jwtEncoder, AuthenticationManagerBuilder authenticationManagerBuilder) {
        this.jwtEncoder = jwtEncoder;
        this.authenticationManagerBuilder = authenticationManagerBuilder;
    }

    @PostMapping("/authenticate")
    public ResponseEntity<JWTToken> authorize(@Valid @RequestBody LoginVM loginVM) {
        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(
            loginVM.getUsername(),
            loginVM.getPassword()
        );

        Authentication authentication = authenticationManagerBuilder.getObject().authenticate(authenticationToken);
        SecurityContextHolder.getContext().setAuthentication(authentication);
        String jwt = this.createToken(authentication, loginVM.isRememberMe());
        HttpHeaders httpHeaders = new HttpHeaders();
        httpHeaders.setBearerAuth(jwt);
        return new ResponseEntity<>(new JWTToken(jwt), httpHeaders, HttpStatus.OK);
    }

    /**
     * {@code GET /authenticate} : check if the user is authenticated, and return its login.
     *
     * @param request the HTTP request.
     * @return the login if the user is authenticated.
     */
    @GetMapping("/authenticate")
    public String isAuthenticated(HttpServletRequest request) {
        log.debug("REST request to check if the current user is authenticated");
        return request.getRemoteUser();
    }

    public String createToken(Authentication authentication, boolean rememberMe) {
        String authorities = authentication.getAuthorities().stream().map(GrantedAuthority::getAuthority).collect(Collectors.joining(" "));

        Instant now = Instant.now();
        Instant validity;
        if (rememberMe) {
            validity = now.plus(this.tokenValidityInSecondsForRememberMe, ChronoUnit.SECONDS);
        } else {
            validity = now.plus(this.tokenValidityInSeconds, ChronoUnit.SECONDS);
        }

        // @formatter:off
        JwtClaimsSet claims = JwtClaimsSet.builder()
            .issuedAt(now)
            .expiresAt(validity)
            .subject(authentication.getName())
            .claim(AUTHORITIES_KEY, authorities)
            .build();

        JwsHeader jwsHeader = JwsHeader.with(JWT_ALGORITHM).build();
        return this.jwtEncoder.encode(JwtEncoderParameters.from(jwsHeader, claims)).getTokenValue();
    }

    /**
     * Object to return as body in JWT Authentication.
     */
    static class JWTToken {

        private String idToken;

        JWTToken(String idToken) {
            this.idToken = idToken;
        }

        @JsonProperty("id_token")
        String getIdToken() {
            return idToken;
        }

        void setIdToken(String idToken) {
            this.idToken = idToken;
        }
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/web/rest/package-info.java
/**
 * Rest layer.
 */
package ee.tenman.mmse.web.rest;


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/web/rest/vm/KeyAndPasswordVM.java
package ee.tenman.mmse.web.rest.vm;

/**
 * View Model object for storing the user's key and password.
 */
public class KeyAndPasswordVM {

    private String key;

    private String newPassword;

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }

    public String getNewPassword() {
        return newPassword;
    }

    public void setNewPassword(String newPassword) {
        this.newPassword = newPassword;
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/web/rest/vm/LoginVM.java
package ee.tenman.mmse.web.rest.vm;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

/**
 * View Model object for storing a user's credentials.
 */
public class LoginVM {

    @NotNull
    @Size(min = 1, max = 50)
    private String username;

    @NotNull
    @Size(min = 4, max = 100)
    private String password;

    private boolean rememberMe;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public boolean isRememberMe() {
        return rememberMe;
    }

    public void setRememberMe(boolean rememberMe) {
        this.rememberMe = rememberMe;
    }

    // prettier-ignore
    @Override
    public String toString() {
        return "LoginVM{" +
            "username='" + username + '\'' +
            ", rememberMe=" + rememberMe +
            '}';
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/web/rest/vm/package-info.java
/**
 * Rest layer visual models.
 */
package ee.tenman.mmse.web.rest.vm;


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/web/rest/vm/ManagedUserVM.java
package ee.tenman.mmse.web.rest.vm;

import ee.tenman.mmse.service.dto.AdminUserDTO;
import jakarta.validation.constraints.Size;

/**
 * View Model extending the AdminUserDTO, which is meant to be used in the user management UI.
 */
public class ManagedUserVM extends AdminUserDTO {

    public static final int PASSWORD_MIN_LENGTH = 4;

    public static final int PASSWORD_MAX_LENGTH = 100;

    @Size(min = PASSWORD_MIN_LENGTH, max = PASSWORD_MAX_LENGTH)
    private String password;

    public ManagedUserVM() {
        // Empty constructor needed for Jackson.
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    // prettier-ignore
    @Override
    public String toString() {
        return "ManagedUserVM{" + super.toString() + "} ";
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/web/rest/errors/LoginAlreadyUsedException.java
package ee.tenman.mmse.web.rest.errors;

@SuppressWarnings("java:S110") // Inheritance tree of classes should not be too deep
public class LoginAlreadyUsedException extends BadRequestAlertException {

    private static final long serialVersionUID = 1L;

    public LoginAlreadyUsedException() {
        super(ErrorConstants.LOGIN_ALREADY_USED_TYPE, "Login name already used!", "userManagement", "userexists");
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/web/rest/errors/BadRequestAlertException.java
package ee.tenman.mmse.web.rest.errors;

import org.springframework.http.HttpStatus;
import org.springframework.web.ErrorResponseException;
import tech.jhipster.web.rest.errors.ProblemDetailWithCause;
import tech.jhipster.web.rest.errors.ProblemDetailWithCause.ProblemDetailWithCauseBuilder;

import java.net.URI;

@SuppressWarnings("java:S110") // Inheritance tree of classes should not be too deep
public class BadRequestAlertException extends ErrorResponseException {

    private static final long serialVersionUID = 1L;

    private final String entityName;

    private final String errorKey;

    public BadRequestAlertException(String defaultMessage, String entityName, String errorKey) {
        this(ErrorConstants.DEFAULT_TYPE, defaultMessage, entityName, errorKey);
    }

    public BadRequestAlertException(URI type, String defaultMessage, String entityName, String errorKey) {
        super(
            HttpStatus.BAD_REQUEST,
            ProblemDetailWithCauseBuilder
                .instance()
                .withStatus(HttpStatus.BAD_REQUEST.value())
                .withType(type)
                .withTitle(defaultMessage)
                .withProperty("message", "error." + errorKey)
                .withProperty("params", entityName)
                .build(),
            null
        );
        this.entityName = entityName;
        this.errorKey = errorKey;
    }

    public String getEntityName() {
        return entityName;
    }

    public String getErrorKey() {
        return errorKey;
    }

    public ProblemDetailWithCause getProblemDetailWithCause() {
        return (ProblemDetailWithCause) this.getBody();
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/web/rest/errors/EmailAlreadyUsedException.java
package ee.tenman.mmse.web.rest.errors;

@SuppressWarnings("java:S110") // Inheritance tree of classes should not be too deep
public class EmailAlreadyUsedException extends BadRequestAlertException {

    private static final long serialVersionUID = 1L;

    public EmailAlreadyUsedException() {
        super(ErrorConstants.EMAIL_ALREADY_USED_TYPE, "Email is already in use!", "userManagement", "emailexists");
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/web/rest/errors/InvalidPasswordException.java
package ee.tenman.mmse.web.rest.errors;

import org.springframework.http.HttpStatus;
import org.springframework.web.ErrorResponseException;
import tech.jhipster.web.rest.errors.ProblemDetailWithCause.ProblemDetailWithCauseBuilder;

@SuppressWarnings("java:S110") // Inheritance tree of classes should not be too deep
public class InvalidPasswordException extends ErrorResponseException {

    private static final long serialVersionUID = 1L;

    public InvalidPasswordException() {
        super(
            HttpStatus.BAD_REQUEST,
            ProblemDetailWithCauseBuilder
                .instance()
                .withStatus(HttpStatus.BAD_REQUEST.value())
                .withType(ErrorConstants.INVALID_PASSWORD_TYPE)
                .withTitle("Incorrect password")
                .build(),
            null
        );
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/web/rest/errors/ErrorConstants.java
package ee.tenman.mmse.web.rest.errors;

import java.net.URI;

public final class ErrorConstants {

    public static final String ERR_CONCURRENCY_FAILURE = "error.concurrencyFailure";
    public static final String ERR_VALIDATION = "error.validation";
    public static final String PROBLEM_BASE_URL = "https://www.jhipster.tech/problem";
    public static final URI DEFAULT_TYPE = URI.create(PROBLEM_BASE_URL + "/problem-with-message");
    public static final URI CONSTRAINT_VIOLATION_TYPE = URI.create(PROBLEM_BASE_URL + "/constraint-violation");
    public static final URI INVALID_PASSWORD_TYPE = URI.create(PROBLEM_BASE_URL + "/invalid-password");
    public static final URI EMAIL_ALREADY_USED_TYPE = URI.create(PROBLEM_BASE_URL + "/email-already-used");
    public static final URI LOGIN_ALREADY_USED_TYPE = URI.create(PROBLEM_BASE_URL + "/login-already-used");

    private ErrorConstants() {
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/web/rest/errors/ExceptionTranslator.java
package ee.tenman.mmse.web.rest.errors;

import jakarta.servlet.http.HttpServletRequest;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.env.Environment;
import org.springframework.dao.ConcurrencyFailureException;
import org.springframework.dao.DataAccessException;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageConversionException;
import org.springframework.lang.Nullable;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.web.ErrorResponse;
import org.springframework.web.ErrorResponseException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;
import tech.jhipster.config.JHipsterConstants;
import tech.jhipster.web.rest.errors.ProblemDetailWithCause;
import tech.jhipster.web.rest.errors.ProblemDetailWithCause.ProblemDetailWithCauseBuilder;
import tech.jhipster.web.util.HeaderUtil;

import java.net.URI;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import static org.springframework.core.annotation.AnnotatedElementUtils.findMergedAnnotation;

/**
 * Controller advice to translate the server side exceptions to client-friendly json structures.
 * The error response follows RFC7807 - Problem Details for HTTP APIs (https://tools.ietf.org/html/rfc7807).
 */
@ControllerAdvice
public class ExceptionTranslator extends ResponseEntityExceptionHandler {

    private static final String FIELD_ERRORS_KEY = "fieldErrors";
    private static final String MESSAGE_KEY = "message";
    private static final String PATH_KEY = "path";
    private static final boolean CASUAL_CHAIN_ENABLED = false;

    @Value("${jhipster.clientApp.name}")
    private String applicationName;

    private final Environment env;

    public ExceptionTranslator(Environment env) {
        this.env = env;
    }

    @ExceptionHandler
    public ResponseEntity<Object> handleAnyException(Throwable ex, NativeWebRequest request) {
        ProblemDetailWithCause pdCause = wrapAndCustomizeProblem(ex, request);
        return handleExceptionInternal(
            (Exception) ex,
            pdCause,
            buildHeaders(ex, request),
            HttpStatusCode.valueOf(pdCause.getStatus()),
            request
        );
    }

    @Nullable
    @Override
    protected ResponseEntity<Object> handleExceptionInternal(
        Exception ex,
        @Nullable Object body,
        HttpHeaders headers,
        HttpStatusCode statusCode,
        WebRequest request
    ) {
        body = body == null ? wrapAndCustomizeProblem((Throwable) ex, (NativeWebRequest) request) : body;
        return super.handleExceptionInternal(ex, body, headers, statusCode, request);
    }

    protected ProblemDetailWithCause wrapAndCustomizeProblem(Throwable ex, NativeWebRequest request) {
        return customizeProblem(getProblemDetailWithCause(ex), ex, request);
    }

    private ProblemDetailWithCause getProblemDetailWithCause(Throwable ex) {
        if (
            ex instanceof ee.tenman.mmse.service.EmailAlreadyUsedException ||
                ex instanceof ee.tenman.mmse.service.UsernameAlreadyUsedException
        ) {
            // return 201 - CREATED on purpose to not reveal information to potential attackers
            // see https://github.com/jhipster/generator-jhipster/issues/21731
            return ProblemDetailWithCauseBuilder.instance().withStatus(201).build();
        }
        if (ex instanceof ee.tenman.mmse.service.InvalidPasswordException)
            return (ProblemDetailWithCause) new InvalidPasswordException()
                .getBody();

        if (
            ex instanceof ErrorResponseException exp && exp.getBody() instanceof ProblemDetailWithCause
        ) return (ProblemDetailWithCause) exp.getBody();
        return ProblemDetailWithCauseBuilder.instance().withStatus(toStatus(ex).value()).build();
    }

    protected ProblemDetailWithCause customizeProblem(ProblemDetailWithCause problem, Throwable err, NativeWebRequest request) {
        if (problem.getStatus() <= 0) problem.setStatus(toStatus(err));

        if (problem.getType() == null || problem.getType().equals(URI.create("about:blank")))
            problem.setType(getMappedType(err));

        // higher precedence to Custom/ResponseStatus types
        String title = extractTitle(err, problem.getStatus());
        String problemTitle = problem.getTitle();
        if (problemTitle == null || !problemTitle.equals(title)) {
            problem.setTitle(title);
        }

        if (problem.getDetail() == null) {
            // higher precedence to cause
            problem.setDetail(getCustomizedErrorDetails(err));
        }

        Map<String, Object> problemProperties = problem.getProperties();
        if (problemProperties == null || !problemProperties.containsKey(MESSAGE_KEY)) problem.setProperty(
            MESSAGE_KEY,
            getMappedMessageKey(err) != null ? getMappedMessageKey(err) : "error.http." + problem.getStatus()
        );

        if (problemProperties == null || !problemProperties.containsKey(PATH_KEY))
            problem.setProperty(PATH_KEY, getPathValue(request));

        if (
            (err instanceof MethodArgumentNotValidException) &&
                (problemProperties == null || !problemProperties.containsKey(FIELD_ERRORS_KEY))
        ) problem.setProperty(FIELD_ERRORS_KEY, getFieldErrors((MethodArgumentNotValidException) err));

        problem.setCause(buildCause(err.getCause(), request).orElse(null));

        return problem;
    }

    private String extractTitle(Throwable err, int statusCode) {
        return getCustomizedTitle(err) != null ? getCustomizedTitle(err) : extractTitleForResponseStatus(err, statusCode);
    }

    private List<FieldErrorVM> getFieldErrors(MethodArgumentNotValidException ex) {
        return ex
            .getBindingResult()
            .getFieldErrors()
            .stream()
            .map(f ->
                new FieldErrorVM(
                    f.getObjectName().replaceFirst("DTO$", ""),
                    f.getField(),
                    StringUtils.isNotBlank(f.getDefaultMessage()) ? f.getDefaultMessage() : f.getCode()
                )
            )
            .toList();
    }

    private String extractTitleForResponseStatus(Throwable err, int statusCode) {
        ResponseStatus specialStatus = extractResponseStatus(err);
        return specialStatus == null ? HttpStatus.valueOf(statusCode).getReasonPhrase() : specialStatus.reason();
    }

    private String extractURI(NativeWebRequest request) {
        HttpServletRequest nativeRequest = request.getNativeRequest(HttpServletRequest.class);
        return nativeRequest != null ? nativeRequest.getRequestURI() : StringUtils.EMPTY;
    }

    private HttpStatus toStatus(final Throwable throwable) {
        // Let the ErrorResponse take this responsibility
        if (throwable instanceof ErrorResponse err) return HttpStatus.valueOf(err.getBody().getStatus());

        return Optional
            .ofNullable(getMappedStatus(throwable))
            .orElse(
                Optional.ofNullable(resolveResponseStatus(throwable)).map(ResponseStatus::value).orElse(HttpStatus.INTERNAL_SERVER_ERROR)
            );
    }

    private ResponseStatus extractResponseStatus(final Throwable throwable) {
        return Optional.ofNullable(resolveResponseStatus(throwable)).orElse(null);
    }

    private ResponseStatus resolveResponseStatus(final Throwable type) {
        final ResponseStatus candidate = findMergedAnnotation(type.getClass(), ResponseStatus.class);
        return candidate == null && type.getCause() != null ? resolveResponseStatus(type.getCause()) : candidate;
    }

    private URI getMappedType(Throwable err) {
        if (err instanceof MethodArgumentNotValidException exp) return ErrorConstants.CONSTRAINT_VIOLATION_TYPE;
        return ErrorConstants.DEFAULT_TYPE;
    }

    private String getMappedMessageKey(Throwable err) {
        if (err instanceof MethodArgumentNotValidException) return ErrorConstants.ERR_VALIDATION;
        else if (
            err instanceof ConcurrencyFailureException || err.getCause() != null && err.getCause() instanceof ConcurrencyFailureException
        ) return ErrorConstants.ERR_CONCURRENCY_FAILURE;
        return null;
    }

    private String getCustomizedTitle(Throwable err) {
        if (err instanceof MethodArgumentNotValidException exp) return "Method argument not valid";
        return null;
    }

    private String getCustomizedErrorDetails(Throwable err) {
        Collection<String> activeProfiles = Arrays.asList(env.getActiveProfiles());
        if (activeProfiles.contains(JHipsterConstants.SPRING_PROFILE_PRODUCTION)) {
            if (err instanceof HttpMessageConversionException) return "Unable to convert http message";
            if (err instanceof DataAccessException) return "Failure during data access";
            if (containsPackageName(err.getMessage())) return "Unexpected runtime exception";
        }
        return err.getCause() != null ? err.getCause().getMessage() : err.getMessage();
    }

    private HttpStatus getMappedStatus(Throwable err) {
        // Where we disagree with Spring defaults
        if (err instanceof AccessDeniedException) return HttpStatus.FORBIDDEN;
        if (err instanceof ConcurrencyFailureException) return HttpStatus.CONFLICT;
        if (err instanceof BadCredentialsException) return HttpStatus.UNAUTHORIZED;
        return null;
    }

    private URI getPathValue(NativeWebRequest request) {
        if (request == null) return URI.create("about:blank");
        return URI.create(extractURI(request));
    }

    private HttpHeaders buildHeaders(Throwable err, NativeWebRequest request) {
        return err instanceof BadRequestAlertException
            ? HeaderUtil.createFailureAlert(
            applicationName,
            true,
            ((BadRequestAlertException) err).getEntityName(),
            ((BadRequestAlertException) err).getErrorKey(),
            ((BadRequestAlertException) err).getMessage()
        )
            : null;
    }

    public Optional<ProblemDetailWithCause> buildCause(final Throwable throwable, NativeWebRequest request) {
        if (throwable != null && isCasualChainEnabled()) {
            return Optional.of(customizeProblem(getProblemDetailWithCause(throwable), throwable, request));
        }
        return Optional.ofNullable(null);
    }

    private boolean isCasualChainEnabled() {
        // Customize as per the needs
        return CASUAL_CHAIN_ENABLED;
    }

    private boolean containsPackageName(String message) {
        // This list is for sure not complete
        return StringUtils.containsAny(message, "org.", "java.", "net.", "jakarta.", "javax.", "com.", "io.", "de.", "ee.tenman.mmse");
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/web/rest/errors/FieldErrorVM.java
package ee.tenman.mmse.web.rest.errors;

import java.io.Serializable;

public class FieldErrorVM implements Serializable {

    private static final long serialVersionUID = 1L;

    private final String objectName;

    private final String field;

    private final String message;

    public FieldErrorVM(String dto, String field, String message) {
        this.objectName = dto;
        this.field = field;
        this.message = message;
    }

    public String getObjectName() {
        return objectName;
    }

    public String getField() {
        return field;
    }

    public String getMessage() {
        return message;
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/web/rest/errors/package-info.java
/**
 * Rest layer error handling.
 */
package ee.tenman.mmse.web.rest.errors;


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/management/SecurityMetersService.java
package ee.tenman.mmse.management;

import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import org.springframework.stereotype.Service;

@Service
public class SecurityMetersService {

    public static final String INVALID_TOKENS_METER_NAME = "security.authentication.invalid-tokens";
    public static final String INVALID_TOKENS_METER_DESCRIPTION =
        "Indicates validation error count of the tokens presented by the clients.";
    public static final String INVALID_TOKENS_METER_BASE_UNIT = "errors";
    public static final String INVALID_TOKENS_METER_CAUSE_DIMENSION = "cause";

    private final Counter tokenInvalidSignatureCounter;
    private final Counter tokenExpiredCounter;
    private final Counter tokenUnsupportedCounter;
    private final Counter tokenMalformedCounter;

    public SecurityMetersService(MeterRegistry registry) {
        this.tokenInvalidSignatureCounter = invalidTokensCounterForCauseBuilder("invalid-signature").register(registry);
        this.tokenExpiredCounter = invalidTokensCounterForCauseBuilder("expired").register(registry);
        this.tokenUnsupportedCounter = invalidTokensCounterForCauseBuilder("unsupported").register(registry);
        this.tokenMalformedCounter = invalidTokensCounterForCauseBuilder("malformed").register(registry);
    }

    private Counter.Builder invalidTokensCounterForCauseBuilder(String cause) {
        return Counter
            .builder(INVALID_TOKENS_METER_NAME)
            .baseUnit(INVALID_TOKENS_METER_BASE_UNIT)
            .description(INVALID_TOKENS_METER_DESCRIPTION)
            .tag(INVALID_TOKENS_METER_CAUSE_DIMENSION, cause);
    }

    public void trackTokenInvalidSignature() {
        this.tokenInvalidSignatureCounter.increment();
    }

    public void trackTokenExpired() {
        this.tokenExpiredCounter.increment();
    }

    public void trackTokenUnsupported() {
        this.tokenUnsupportedCounter.increment();
    }

    public void trackTokenMalformed() {
        this.tokenMalformedCounter.increment();
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/management/package-info.java
/**
 * Application management.
 */
package ee.tenman.mmse.management;


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/aop/logging/LoggingAspect.java
package ee.tenman.mmse.aop.logging;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.AfterThrowing;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.env.Environment;
import org.springframework.core.env.Profiles;
import tech.jhipster.config.JHipsterConstants;

import java.util.Arrays;

/**
 * Aspect for logging execution of service and repository Spring components.
 * <p>
 * By default, it only runs with the "dev" profile.
 */
@Aspect
public class LoggingAspect {

    private final Environment env;

    public LoggingAspect(Environment env) {
        this.env = env;
    }

    /**
     * Pointcut that matches all repositories, services and Web REST endpoints.
     */
    @Pointcut(
        "within(@org.springframework.stereotype.Repository *)" +
            " || within(@org.springframework.stereotype.Service *)" +
            " || within(@org.springframework.web.bind.annotation.RestController *)"
    )
    public void springBeanPointcut() {
        // Method is empty as this is just a Pointcut, the implementations are in the advices.
    }

    /**
     * Pointcut that matches all Spring beans in the application's main packages.
     */
    @Pointcut("within(ee.tenman.mmse.repository..*)" + " || within(ee.tenman.mmse.service..*)" + " || within(ee.tenman.mmse.web.rest..*)")
    public void applicationPackagePointcut() {
        // Method is empty as this is just a Pointcut, the implementations are in the advices.
    }

    /**
     * Retrieves the {@link Logger} associated to the given {@link JoinPoint}.
     *
     * @param joinPoint join point we want the logger for.
     * @return {@link Logger} associated to the given {@link JoinPoint}.
     */
    private Logger logger(JoinPoint joinPoint) {
        return LoggerFactory.getLogger(joinPoint.getSignature().getDeclaringTypeName());
    }

    /**
     * Advice that logs methods throwing exceptions.
     *
     * @param joinPoint join point for advice.
     * @param e         exception.
     */
    @AfterThrowing(pointcut = "applicationPackagePointcut() && springBeanPointcut()", throwing = "e")
    public void logAfterThrowing(JoinPoint joinPoint, Throwable e) {
        if (env.acceptsProfiles(Profiles.of(JHipsterConstants.SPRING_PROFILE_DEVELOPMENT))) {
            logger(joinPoint)
                .error(
                    "Exception in {}() with cause = '{}' and exception = '{}'",
                    joinPoint.getSignature().getName(),
                    e.getCause() != null ? e.getCause() : "NULL",
                    e.getMessage(),
                    e
                );
        } else {
            logger(joinPoint)
                .error(
                    "Exception in {}() with cause = {}",
                    joinPoint.getSignature().getName(),
                    e.getCause() != null ? e.getCause() : "NULL"
                );
        }
    }

    /**
     * Advice that logs when a method is entered and exited.
     *
     * @param joinPoint join point for advice.
     * @return result.
     * @throws Throwable throws {@link IllegalArgumentException}.
     */
    @Around("applicationPackagePointcut() && springBeanPointcut()")
    public Object logAround(ProceedingJoinPoint joinPoint) throws Throwable {
        Logger log = logger(joinPoint);
        if (log.isDebugEnabled()) {
            log.debug("Enter: {}() with argument[s] = {}", joinPoint.getSignature().getName(), Arrays.toString(joinPoint.getArgs()));
        }
        try {
            Object result = joinPoint.proceed();
            if (log.isDebugEnabled()) {
                log.debug("Exit: {}() with result = {}", joinPoint.getSignature().getName(), result);
            }
            return result;
        } catch (IllegalArgumentException e) {
            log.error("Illegal argument: {} in {}()", Arrays.toString(joinPoint.getArgs()), joinPoint.getSignature().getName());
            throw e;
        }
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/aop/logging/package-info.java
/**
 * Logging aspect.
 */
package ee.tenman.mmse.aop.logging;


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/UserService.java
package ee.tenman.mmse.service;

import ee.tenman.mmse.config.Constants;
import ee.tenman.mmse.domain.Authority;
import ee.tenman.mmse.domain.User;
import ee.tenman.mmse.repository.AuthorityRepository;
import ee.tenman.mmse.repository.UserRepository;
import ee.tenman.mmse.security.AuthoritiesConstants;
import ee.tenman.mmse.security.SecurityUtils;
import ee.tenman.mmse.service.dto.AdminUserDTO;
import ee.tenman.mmse.service.dto.UserDTO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tech.jhipster.security.RandomUtil;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.HashSet;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Service class for managing users.
 */
@Service
@Transactional
public class UserService {

    private final Logger log = LoggerFactory.getLogger(UserService.class);

    private final UserRepository userRepository;

    private final PasswordEncoder passwordEncoder;

    private final AuthorityRepository authorityRepository;

    public UserService(UserRepository userRepository, PasswordEncoder passwordEncoder, AuthorityRepository authorityRepository) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
        this.authorityRepository = authorityRepository;
    }

    public Optional<User> activateRegistration(String key) {
        log.debug("Activating user for activation key {}", key);
        return userRepository
            .findOneByActivationKey(key)
            .map(user -> {
                // activate given user for the registration key.
                user.setActivated(true);
                user.setActivationKey(null);
                log.debug("Activated user: {}", user);
                return user;
            });
    }

    public Optional<User> completePasswordReset(String newPassword, String key) {
        log.debug("Reset user password for reset key {}", key);
        return userRepository
            .findOneByResetKey(key)
            .filter(user -> user.getResetDate().isAfter(Instant.now().minus(1, ChronoUnit.DAYS)))
            .map(user -> {
                user.setPassword(passwordEncoder.encode(newPassword));
                user.setResetKey(null);
                user.setResetDate(null);
                return user;
            });
    }

    public Optional<User> requestPasswordReset(String mail) {
        return userRepository
            .findOneByEmailIgnoreCase(mail)
            .filter(User::isActivated)
            .map(user -> {
                user.setResetKey(RandomUtil.generateResetKey());
                user.setResetDate(Instant.now());
                return user;
            });
    }

    public User registerUser(AdminUserDTO userDTO, String password) {
        userRepository
            .findOneByLogin(userDTO.getLogin().toLowerCase())
            .ifPresent(existingUser -> {
                boolean removed = removeNonActivatedUser(existingUser);
                if (!removed) {
                    throw new UsernameAlreadyUsedException();
                }
            });
        userRepository
            .findOneByEmailIgnoreCase(userDTO.getEmail())
            .ifPresent(existingUser -> {
                boolean removed = removeNonActivatedUser(existingUser);
                if (!removed) {
                    throw new EmailAlreadyUsedException();
                }
            });
        User newUser = new User();
        String encryptedPassword = passwordEncoder.encode(password);
        newUser.setLogin(userDTO.getLogin().toLowerCase());
        // new user gets initially a generated password
        newUser.setPassword(encryptedPassword);
        newUser.setFirstName(userDTO.getFirstName());
        newUser.setLastName(userDTO.getLastName());
        if (userDTO.getEmail() != null) {
            newUser.setEmail(userDTO.getEmail().toLowerCase());
        }
        newUser.setImageUrl(userDTO.getImageUrl());
        newUser.setLangKey(userDTO.getLangKey());
        // new user is not active
        newUser.setActivated(false);
        // new user gets registration key
        newUser.setActivationKey(RandomUtil.generateActivationKey());
        Set<Authority> authorities = new HashSet<>();
        authorityRepository.findById(AuthoritiesConstants.USER).ifPresent(authorities::add);
        newUser.setAuthorities(authorities);
        userRepository.save(newUser);
        log.debug("Created Information for User: {}", newUser);
        return newUser;
    }

    private boolean removeNonActivatedUser(User existingUser) {
        if (existingUser.isActivated()) {
            return false;
        }
        userRepository.delete(existingUser);
        userRepository.flush();
        return true;
    }

    public User createUser(AdminUserDTO userDTO) {
        User user = new User();
        user.setLogin(userDTO.getLogin().toLowerCase());
        user.setFirstName(userDTO.getFirstName());
        user.setLastName(userDTO.getLastName());
        if (userDTO.getEmail() != null) {
            user.setEmail(userDTO.getEmail().toLowerCase());
        }
        user.setImageUrl(userDTO.getImageUrl());
        if (userDTO.getLangKey() == null) {
            user.setLangKey(Constants.DEFAULT_LANGUAGE); // default language
        } else {
            user.setLangKey(userDTO.getLangKey());
        }
        String encryptedPassword = passwordEncoder.encode(RandomUtil.generatePassword());
        user.setPassword(encryptedPassword);
        user.setResetKey(RandomUtil.generateResetKey());
        user.setResetDate(Instant.now());
        user.setActivated(true);
        if (userDTO.getAuthorities() != null) {
            Set<Authority> authorities = userDTO
                .getAuthorities()
                .stream()
                .map(authorityRepository::findById)
                .filter(Optional::isPresent)
                .map(Optional::get)
                .collect(Collectors.toSet());
            user.setAuthorities(authorities);
        }
        userRepository.save(user);
        log.debug("Created Information for User: {}", user);
        return user;
    }

    /**
     * Update all information for a specific user, and return the modified user.
     *
     * @param userDTO user to update.
     * @return updated user.
     */
    public Optional<AdminUserDTO> updateUser(AdminUserDTO userDTO) {
        return Optional
            .of(userRepository.findById(userDTO.getId()))
            .filter(Optional::isPresent)
            .map(Optional::get)
            .map(user -> {
                user.setLogin(userDTO.getLogin().toLowerCase());
                user.setFirstName(userDTO.getFirstName());
                user.setLastName(userDTO.getLastName());
                if (userDTO.getEmail() != null) {
                    user.setEmail(userDTO.getEmail().toLowerCase());
                }
                user.setImageUrl(userDTO.getImageUrl());
                user.setActivated(userDTO.isActivated());
                user.setLangKey(userDTO.getLangKey());
                Set<Authority> managedAuthorities = user.getAuthorities();
                managedAuthorities.clear();
                userDTO
                    .getAuthorities()
                    .stream()
                    .map(authorityRepository::findById)
                    .filter(Optional::isPresent)
                    .map(Optional::get)
                    .forEach(managedAuthorities::add);
                userRepository.save(user);
                log.debug("Changed Information for User: {}", user);
                return user;
            })
            .map(AdminUserDTO::new);
    }

    public void deleteUser(String login) {
        userRepository
            .findOneByLogin(login)
            .ifPresent(user -> {
                userRepository.delete(user);
                log.debug("Deleted User: {}", user);
            });
    }

    /**
     * Update basic information (first name, last name, email, language) for the current user.
     *
     * @param firstName first name of user.
     * @param lastName  last name of user.
     * @param email     email id of user.
     * @param langKey   language key.
     * @param imageUrl  image URL of user.
     */
    public void updateUser(String firstName, String lastName, String email, String langKey, String imageUrl) {
        SecurityUtils
            .getCurrentUserLogin()
            .flatMap(userRepository::findOneByLogin)
            .ifPresent(user -> {
                user.setFirstName(firstName);
                user.setLastName(lastName);
                if (email != null) {
                    user.setEmail(email.toLowerCase());
                }
                user.setLangKey(langKey);
                user.setImageUrl(imageUrl);
                userRepository.save(user);
                log.debug("Changed Information for User: {}", user);
            });
    }

    @Transactional
    public void changePassword(String currentClearTextPassword, String newPassword) {
        SecurityUtils
            .getCurrentUserLogin()
            .flatMap(userRepository::findOneByLogin)
            .ifPresent(user -> {
                String currentEncryptedPassword = user.getPassword();
                if (!passwordEncoder.matches(currentClearTextPassword, currentEncryptedPassword)) {
                    throw new InvalidPasswordException();
                }
                String encryptedPassword = passwordEncoder.encode(newPassword);
                user.setPassword(encryptedPassword);
                log.debug("Changed password for User: {}", user);
            });
    }

    @Transactional(readOnly = true)
    public Page<AdminUserDTO> getAllManagedUsers(Pageable pageable) {
        return userRepository.findAll(pageable).map(AdminUserDTO::new);
    }

    @Transactional(readOnly = true)
    public Page<UserDTO> getAllPublicUsers(Pageable pageable) {
        return userRepository.findAllByIdNotNullAndActivatedIsTrue(pageable).map(UserDTO::new);
    }

    @Transactional(readOnly = true)
    public Optional<User> getUserWithAuthoritiesByLogin(String login) {
        return userRepository.findOneWithAuthoritiesByLogin(login);
    }

    @Transactional(readOnly = true)
    public Optional<User> findUserWithAuthorities() {
        return SecurityUtils.getCurrentUserLogin().flatMap(userRepository::findOneWithAuthoritiesByLogin);
    }


    @Transactional(readOnly = true)
    public User getUserWithAuthorities() {
        return SecurityUtils.getCurrentUserLogin().flatMap(userRepository::findOneWithAuthoritiesByLogin)
            .orElseThrow(() -> new NoSuchElementException("User not found"));
    }

    /**
     * Not activated users should be automatically deleted after 3 days.
     * <p>
     * This is scheduled to get fired everyday, at 01:00 (am).
     */
    @Scheduled(cron = "0 0 1 * * ?")
    public void removeNotActivatedUsers() {
        userRepository
            .findAllByActivatedIsFalseAndActivationKeyIsNotNullAndCreatedDateBefore(Instant.now().minus(3, ChronoUnit.DAYS))
            .forEach(user -> {
                log.debug("Deleting not activated user {}", user.getLogin());
                userRepository.delete(user);
            });
    }

    /**
     * Gets a list of all the authorities.
     *
     * @return a list of all the authorities.
     */
    @Transactional(readOnly = true)
    public List<String> getAuthorities() {
        return authorityRepository.findAll().stream().map(Authority::getName).toList();
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/MailService.java
package ee.tenman.mmse.service;

import ee.tenman.mmse.domain.User;
import jakarta.mail.MessagingException;
import jakarta.mail.internet.MimeMessage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.MessageSource;
import org.springframework.mail.MailException;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.thymeleaf.context.Context;
import org.thymeleaf.spring6.SpringTemplateEngine;
import tech.jhipster.config.JHipsterProperties;

import java.nio.charset.StandardCharsets;
import java.util.Locale;

/**
 * Service for sending emails.
 * <p>
 * We use the {@link Async} annotation to send emails asynchronously.
 */
@Service
public class MailService {

    private final Logger log = LoggerFactory.getLogger(MailService.class);

    private static final String USER = "user";

    private static final String BASE_URL = "baseUrl";

    private final JHipsterProperties jHipsterProperties;

    private final JavaMailSender javaMailSender;

    private final MessageSource messageSource;

    private final SpringTemplateEngine templateEngine;

    public MailService(
        JHipsterProperties jHipsterProperties,
        JavaMailSender javaMailSender,
        MessageSource messageSource,
        SpringTemplateEngine templateEngine
    ) {
        this.jHipsterProperties = jHipsterProperties;
        this.javaMailSender = javaMailSender;
        this.messageSource = messageSource;
        this.templateEngine = templateEngine;
    }

    @Async
    public void sendEmail(String to, String subject, String content, boolean isMultipart, boolean isHtml) {
        log.debug(
            "Send email[multipart '{}' and html '{}'] to '{}' with subject '{}' and content={}",
            isMultipart,
            isHtml,
            to,
            subject,
            content
        );

        // Prepare message using a Spring helper
        MimeMessage mimeMessage = javaMailSender.createMimeMessage();
        try {
            MimeMessageHelper message = new MimeMessageHelper(mimeMessage, isMultipart, StandardCharsets.UTF_8.name());
            message.setTo(to);
            message.setFrom(jHipsterProperties.getMail().getFrom());
            message.setSubject(subject);
            message.setText(content, isHtml);
            javaMailSender.send(mimeMessage);
            log.debug("Sent email to User '{}'", to);
        } catch (MailException | MessagingException e) {
            log.warn("Email could not be sent to user '{}'", to, e);
        }
    }

    @Async
    public void sendEmailFromTemplate(User user, String templateName, String titleKey) {
        if (user.getEmail() == null) {
            log.debug("Email doesn't exist for user '{}'", user.getLogin());
            return;
        }
        Locale locale = Locale.forLanguageTag(user.getLangKey());
        Context context = new Context(locale);
        context.setVariable(USER, user);
        context.setVariable(BASE_URL, jHipsterProperties.getMail().getBaseUrl());
        String content = templateEngine.process(templateName, context);
        String subject = messageSource.getMessage(titleKey, null, locale);
        sendEmail(user.getEmail(), subject, content, false, true);
    }

    @Async
    public void sendActivationEmail(User user) {
        log.debug("Sending activation email to '{}'", user.getEmail());
        sendEmailFromTemplate(user, "mail/activationEmail", "email.activation.title");
    }

    @Async
    public void sendCreationEmail(User user) {
        log.debug("Sending creation email to '{}'", user.getEmail());
        sendEmailFromTemplate(user, "mail/creationEmail", "email.activation.title");
    }

    @Async
    public void sendPasswordResetMail(User user) {
        log.debug("Sending password reset email to '{}'", user.getEmail());
        sendEmailFromTemplate(user, "mail/passwordResetEmail", "email.reset.title");
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/TestEntityService.java
package ee.tenman.mmse.service;

import ee.tenman.mmse.domain.TestEntity;
import ee.tenman.mmse.domain.UserAnswer;
import ee.tenman.mmse.repository.TestEntityRepository;
import ee.tenman.mmse.repository.UserAnswerRepository;
import ee.tenman.mmse.service.dto.TestEntityDTO;
import ee.tenman.mmse.service.mapper.TestEntityMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

/**
 * Service Implementation for managing {@link TestEntity}.
 */
@Service
@Transactional
public class TestEntityService {

    private final Logger log = LoggerFactory.getLogger(TestEntityService.class);

    private final TestEntityRepository testEntityRepository;

    private final UserAnswerRepository userAnswerRepository;

    private final TestEntityMapper testEntityMapper;

    public TestEntityService(
        TestEntityRepository testEntityRepository,
        TestEntityMapper testEntityMapper,
        UserAnswerRepository userAnswerRepository
    ) {
        this.testEntityRepository = testEntityRepository;
        this.testEntityMapper = testEntityMapper;
        this.userAnswerRepository = userAnswerRepository;
    }

    /**
     * Save a testEntity.
     *
     * @param testEntityDTO the entity to save.
     * @return the persisted entity.
     */
    public TestEntityDTO save(TestEntityDTO testEntityDTO) {
        log.debug("Request to save TestEntity : {}", testEntityDTO);
        TestEntity testEntity = testEntityMapper.toEntity(testEntityDTO);
        testEntity = testEntityRepository.save(testEntity);
        return testEntityMapper.toDto(testEntity);
    }

    /**
     * Update a testEntity.
     *
     * @param testEntityDTO the entity to save.
     * @return the persisted entity.
     */
    public TestEntityDTO update(TestEntityDTO testEntityDTO) {
        log.debug("Request to update TestEntity : {}", testEntityDTO);
        TestEntity testEntity = testEntityMapper.toEntity(testEntityDTO);
        testEntity = testEntityRepository.save(testEntity);
        return testEntityMapper.toDto(testEntity);
    }

    /**
     * Partially update a testEntity.
     *
     * @param testEntityDTO the entity to update partially.
     * @return the persisted entity.
     */
    public Optional<TestEntityDTO> partialUpdate(TestEntityDTO testEntityDTO) {
        log.debug("Request to partially update TestEntity : {}", testEntityDTO);

        return testEntityRepository
            .findById(testEntityDTO.getId())
            .map(existingTestEntity -> {
                testEntityMapper.partialUpdate(existingTestEntity, testEntityDTO);

                return existingTestEntity;
            })
            .map(testEntityRepository::save)
            .map(testEntityMapper::toDto);
    }

    /**
     * Get all the testEntities.
     *
     * @param pageable the pagination information.
     * @return the list of entities.
     */
    @Transactional(readOnly = true)
    public Page<TestEntityDTO> findAll(Pageable pageable) {
        log.debug("Request to get all TestEntities");
        return testEntityRepository.findAll(pageable).map(testEntityMapper::toDto);
    }

    /**
     * Get all the testEntities with eager load of many-to-many relationships.
     *
     * @return the list of entities.
     */
    public Page<TestEntityDTO> findAllWithEagerRelationships(Pageable pageable) {
        return testEntityRepository.findAllWithEagerRelationships(pageable).map(testEntityMapper::toDto);
    }

    /**
     * Get one testEntity by id.
     *
     * @param id the id of the entity.
     * @return the entity.
     */
    @Transactional(readOnly = true)
    public Optional<TestEntityDTO> findOne(Long id) {
        log.debug("Request to get TestEntity : {}", id);
        return testEntityRepository.findOneWithEagerRelationships(id).map(testEntityMapper::toDto);
    }

    /**
     * Delete the testEntity by id.
     *
     * @param id the id of the entity.
     */
    public void delete(Long id) {
        List<UserAnswer> answers = userAnswerRepository.findByTestEntityIdOrderByCreatedAtDesc(id);
        userAnswerRepository.deleteAll(answers);
        log.debug("Request to delete TestEntity : {}", id);
        testEntityRepository.deleteById(id);
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/UserAnswerService.java
package ee.tenman.mmse.service;

import ee.tenman.mmse.domain.TestEntity;
import ee.tenman.mmse.domain.User;
import ee.tenman.mmse.domain.UserAnswer;
import ee.tenman.mmse.repository.TestEntityRepository;
import ee.tenman.mmse.repository.UserAnswerRepository;
import ee.tenman.mmse.service.dto.UserAnswerDTO;
import ee.tenman.mmse.service.mapper.UserAnswerMapper;
import jakarta.annotation.Resource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

/**
 * Service Implementation for managing {@link UserAnswer}.
 */
@Service
@Transactional
public class UserAnswerService {

    private final Logger log = LoggerFactory.getLogger(UserAnswerService.class);

    @Resource
    private UserAnswerRepository userAnswerRepository;
    @Resource
    private UserAnswerMapper userAnswerMapper;
    @Resource
    private TestEntityRepository testEntityRepository;
    @Resource
    private UserService userService;

    /**
     * Save a userAnswer.
     *
     * @param userAnswerDTO the entity to save.
     * @return the persisted entity.
     */
    public UserAnswerDTO save(UserAnswerDTO userAnswerDTO) {
        log.debug("Request to save UserAnswer : {}", userAnswerDTO);
        UserAnswer userAnswer = userAnswerMapper.toEntity(userAnswerDTO);
        userAnswer = userAnswerRepository.save(userAnswer);
        return userAnswerMapper.toDto(userAnswer);
    }

    /**
     * Update a userAnswer.
     *
     * @param userAnswerDTO the entity to save.
     * @return the persisted entity.
     */
    public UserAnswerDTO update(UserAnswerDTO userAnswerDTO) {
        log.debug("Request to update UserAnswer : {}", userAnswerDTO);
        UserAnswer userAnswer = userAnswerMapper.toEntity(userAnswerDTO);
        userAnswer = userAnswerRepository.save(userAnswer);
        return userAnswerMapper.toDto(userAnswer);
    }

    /**
     * Partially update a userAnswer.
     *
     * @param userAnswerDTO the entity to update partially.
     * @return the persisted entity.
     */
    public Optional<UserAnswerDTO> partialUpdate(UserAnswerDTO userAnswerDTO) {
        log.debug("Request to partially update UserAnswer : {}", userAnswerDTO);

        return userAnswerRepository
            .findById(userAnswerDTO.getId())
            .map(existingUserAnswer -> {
                userAnswerMapper.partialUpdate(existingUserAnswer, userAnswerDTO);

                return existingUserAnswer;
            })
            .map(userAnswerRepository::save)
            .map(userAnswerMapper::toDto);
    }

    /**
     * Get all the userAnswers.
     *
     * @param pageable the pagination information.
     * @return the list of entities.
     */
    @Transactional(readOnly = true)
    public Page<UserAnswerDTO> findAll(Pageable pageable) {
        log.debug("Request to get all UserAnswers");
        return userAnswerRepository.findAll(pageable).map(userAnswerMapper::toDto);
    }

    /**
     * Get one userAnswer by id.
     *
     * @param id the id of the entity.
     * @return the entity.
     */
    @Transactional(readOnly = true)
    public Optional<UserAnswerDTO> findOne(Long id) {
        log.debug("Request to get UserAnswer : {}", id);
        return userAnswerRepository.findById(id).map(userAnswerMapper::toDto);
    }

    /**
     * Delete the userAnswer by id.
     *
     * @param id the id of the entity.
     */
    public void delete(Long id) {
        log.debug("Request to delete UserAnswer : {}", id);
        userAnswerRepository.deleteById(id);
    }

    public Optional<UserAnswer> getLatest() {
        Optional<User> user = userService.findUserWithAuthorities();
        if (user.isEmpty()) {
            throw new RuntimeException("No logged in user found");
        }
        Long userId = user.get().getId();
        Optional<TestEntity> latestTestEntity = testEntityRepository.findLatestByUserId(userId, PageRequest.of(0, 1)).stream().findFirst();

        if (latestTestEntity.isEmpty()) {
            return Optional.empty();
        }

        return latestTestEntity.flatMap(testEntity ->
            userAnswerRepository.findLatestByTestEntityId(testEntity.getId(), PageRequest.of(0, 1)).stream().findFirst()
        );
    }

}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/EmailAlreadyUsedException.java
package ee.tenman.mmse.service;

public class EmailAlreadyUsedException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    public EmailAlreadyUsedException() {
        super("Email is already in use!");
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/CalculateScoreScheduler.java
package ee.tenman.mmse.service;

import ee.tenman.mmse.domain.UserAnswer;
import ee.tenman.mmse.domain.enumeration.QuestionId;
import ee.tenman.mmse.repository.UserAnswerRepository;
import ee.tenman.mmse.service.lock.Lock;
import ee.tenman.mmse.service.question.Question;
import ee.tenman.mmse.service.question.QuestionsConfig;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Map;

@Component
public class CalculateScoreScheduler {

    private final Logger log = LoggerFactory.getLogger(CalculateScoreScheduler.class);

    private final Map<QuestionId, Question> questions;
    private final UserAnswerRepository userAnswerRepository;

    @Autowired
    public CalculateScoreScheduler(QuestionsConfig questionsConfig, UserAnswerRepository userAnswerRepository) {
        this.questions = questionsConfig.getQuestions();
        this.userAnswerRepository = userAnswerRepository;
    }

    @Scheduled(fixedDelay = 5000)
    @Lock(key = "'calculateUnscored'", retry = false)
    public void calculateUnscored() {
        List<UserAnswer> answers;
        do {
            answers = userAnswerRepository.findUnscored();
            for (UserAnswer userAnswer : answers) {
                Question question = questions.get(userAnswer.getQuestionId());
                if (question == null) {
                    log.warn("No Question found for ID: {}", userAnswer.getQuestionId());
                    continue;
                }
                int score = userAnswer.getScore() == null ? question.getScore(userAnswer) : userAnswer.getScore();
                userAnswer.setScore(score);
                userAnswer.setMaximumScore(question.getMaximumScore());
            }
            userAnswerRepository.saveAll(answers);
        } while (!answers.isEmpty());
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/InvalidPasswordException.java
package ee.tenman.mmse.service;

public class InvalidPasswordException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    public InvalidPasswordException() {
        super("Incorrect password");
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/UsernameAlreadyUsedException.java
package ee.tenman.mmse.service;

public class UsernameAlreadyUsedException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    public UsernameAlreadyUsedException() {
        super("Login name already used!");
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/package-info.java
/**
 * Service layer.
 */
package ee.tenman.mmse.service;


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/dto/PasswordChangeDTO.java
package ee.tenman.mmse.service.dto;

import java.io.Serializable;

/**
 * A DTO representing a password change required data - current and new password.
 */
public class PasswordChangeDTO implements Serializable {

    private static final long serialVersionUID = 1L;

    private String currentPassword;
    private String newPassword;

    public PasswordChangeDTO() {
        // Empty constructor needed for Jackson.
    }

    public PasswordChangeDTO(String currentPassword, String newPassword) {
        this.currentPassword = currentPassword;
        this.newPassword = newPassword;
    }

    public String getCurrentPassword() {
        return currentPassword;
    }

    public void setCurrentPassword(String currentPassword) {
        this.currentPassword = currentPassword;
    }

    public String getNewPassword() {
        return newPassword;
    }

    public void setNewPassword(String newPassword) {
        this.newPassword = newPassword;
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/dto/UserAnswerDTO.java
package ee.tenman.mmse.service.dto;

import ee.tenman.mmse.domain.enumeration.QuestionId;
import jakarta.validation.constraints.NotNull;

import java.io.Serializable;
import java.time.Instant;
import java.util.Objects;

/**
 * A DTO for the {@link ee.tenman.mmse.domain.UserAnswer} entity.
 */
@SuppressWarnings("common-java:DuplicatedBlocks")
public class UserAnswerDTO implements Serializable {

    private Long id;

    private String answerText;

    @NotNull
    private Instant createdAt;

    private Instant updatedAt;

    @NotNull
    private QuestionId questionId;

    private TestEntityDTO testEntity;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getAnswerText() {
        return answerText;
    }

    public void setAnswerText(String answerText) {
        this.answerText = answerText;
    }

    public Instant getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(Instant createdAt) {
        this.createdAt = createdAt;
    }

    public Instant getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(Instant updatedAt) {
        this.updatedAt = updatedAt;
    }

    public QuestionId getQuestionId() {
        return questionId;
    }

    public void setQuestionId(QuestionId questionId) {
        this.questionId = questionId;
    }

    public TestEntityDTO getTestEntity() {
        return testEntity;
    }

    public void setTestEntity(TestEntityDTO testEntity) {
        this.testEntity = testEntity;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof UserAnswerDTO)) {
            return false;
        }

        UserAnswerDTO userAnswerDTO = (UserAnswerDTO) o;
        if (this.id == null) {
            return false;
        }
        return Objects.equals(this.id, userAnswerDTO.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(this.id);
    }

    // prettier-ignore
    @Override
    public String toString() {
        return "UserAnswerDTO{" +
            "id=" + getId() +
            ", answerText='" + getAnswerText() + "'" +
            ", createdAt='" + getCreatedAt() + "'" +
            ", updatedAt='" + getUpdatedAt() + "'" +
            ", questionId='" + getQuestionId() + "'" +
            ", testEntity=" + getTestEntity() +
            "}";
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/dto/AnswerDTO.java
package ee.tenman.mmse.service.dto;

import ee.tenman.mmse.domain.enumeration.QuestionId;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;

import java.io.Serializable;
import java.util.Objects;

public class AnswerDTO implements Serializable {

    private Long id;

    @NotEmpty
    private String idempotencyKey;

    @NotEmpty
    private String answerText;

    @NotNull
    private QuestionId questionId;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getAnswerText() {
        return answerText;
    }

    public void setAnswerText(String answerText) {
        this.answerText = answerText;
    }

    public QuestionId getQuestionId() {
        return questionId;
    }

    public void setQuestionId(QuestionId questionId) {
        this.questionId = questionId;
    }

    public String getIdempotencyKey() {
        return idempotencyKey;
    }

    public void setIdempotencyKey(String idempotencyKey) {
        this.idempotencyKey = idempotencyKey;
    }

    @Override
    public String toString() {
        return "AnswerDTO{" +
            "id=" + id +
            ", answerText='" + answerText + '\'' +
            ", questionId=" + questionId +
            ", idempotencyKey=" + idempotencyKey +
            '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        AnswerDTO answerDTO = (AnswerDTO) o;
        return Objects.equals(id, answerDTO.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/dto/QuestionResponse.java
package ee.tenman.mmse.service.dto;

public class QuestionResponse<T> {
    private T question;
    private Long testEntityId;

    public QuestionResponse(T question, Long testEntityId) {
        this.question = question;
        this.testEntityId = testEntityId;
    }

    public T getQuestion() {
        return question;
    }

    public void setQuestion(T question) {
        this.question = question;
    }

    public Long getTestEntityId() {
        return testEntityId;
    }

    public void setTestEntityId(Long testEntityId) {
        this.testEntityId = testEntityId;
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/dto/AdminUserDTO.java
package ee.tenman.mmse.service.dto;

import ee.tenman.mmse.config.Constants;
import ee.tenman.mmse.domain.Authority;
import ee.tenman.mmse.domain.User;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

import java.io.Serializable;
import java.time.Instant;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * A DTO representing a user, with his authorities.
 */
public class AdminUserDTO implements Serializable {

    private static final long serialVersionUID = 1L;

    private Long id;

    @NotBlank
    @Pattern(regexp = Constants.LOGIN_REGEX)
    @Size(min = 1, max = 50)
    private String login;

    @Size(max = 50)
    private String firstName;

    @Size(max = 50)
    private String lastName;

    @Email
    @Size(min = 5, max = 254)
    private String email;

    @Size(max = 256)
    private String imageUrl;

    private boolean activated = false;

    @Size(min = 2, max = 10)
    private String langKey;

    private String createdBy;

    private Instant createdDate;

    private String lastModifiedBy;

    private Instant lastModifiedDate;

    private Set<String> authorities;

    public AdminUserDTO() {
        // Empty constructor needed for Jackson.
    }

    public AdminUserDTO(User user) {
        this.id = user.getId();
        this.login = user.getLogin();
        this.firstName = user.getFirstName();
        this.lastName = user.getLastName();
        this.email = user.getEmail();
        this.activated = user.isActivated();
        this.imageUrl = user.getImageUrl();
        this.langKey = user.getLangKey();
        this.createdBy = user.getCreatedBy();
        this.createdDate = user.getCreatedDate();
        this.lastModifiedBy = user.getLastModifiedBy();
        this.lastModifiedDate = user.getLastModifiedDate();
        this.authorities = user.getAuthorities().stream().map(Authority::getName).collect(Collectors.toSet());
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getLogin() {
        return login;
    }

    public void setLogin(String login) {
        this.login = login;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getImageUrl() {
        return imageUrl;
    }

    public void setImageUrl(String imageUrl) {
        this.imageUrl = imageUrl;
    }

    public boolean isActivated() {
        return activated;
    }

    public void setActivated(boolean activated) {
        this.activated = activated;
    }

    public String getLangKey() {
        return langKey;
    }

    public void setLangKey(String langKey) {
        this.langKey = langKey;
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }

    public Instant getCreatedDate() {
        return createdDate;
    }

    public void setCreatedDate(Instant createdDate) {
        this.createdDate = createdDate;
    }

    public String getLastModifiedBy() {
        return lastModifiedBy;
    }

    public void setLastModifiedBy(String lastModifiedBy) {
        this.lastModifiedBy = lastModifiedBy;
    }

    public Instant getLastModifiedDate() {
        return lastModifiedDate;
    }

    public void setLastModifiedDate(Instant lastModifiedDate) {
        this.lastModifiedDate = lastModifiedDate;
    }

    public Set<String> getAuthorities() {
        return authorities;
    }

    public void setAuthorities(Set<String> authorities) {
        this.authorities = authorities;
    }

    // prettier-ignore
    @Override
    public String toString() {
        return "AdminUserDTO{" +
            "login='" + login + '\'' +
            ", firstName='" + firstName + '\'' +
            ", lastName='" + lastName + '\'' +
            ", email='" + email + '\'' +
            ", imageUrl='" + imageUrl + '\'' +
            ", activated=" + activated +
            ", langKey='" + langKey + '\'' +
            ", createdBy=" + createdBy +
            ", createdDate=" + createdDate +
            ", lastModifiedBy='" + lastModifiedBy + '\'' +
            ", lastModifiedDate=" + lastModifiedDate +
            ", authorities=" + authorities +
            "}";
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/dto/UserDTO.java
package ee.tenman.mmse.service.dto;

import ee.tenman.mmse.domain.User;

import java.io.Serializable;

/**
 * A DTO representing a user, with only the public attributes.
 */
public class UserDTO implements Serializable {

    private static final long serialVersionUID = 1L;

    private Long id;

    private String login;

    public UserDTO() {
        // Empty constructor needed for Jackson.
    }

    public UserDTO(User user) {
        this.id = user.getId();
        // Customize it here if you need, or not, firstName/lastName/etc
        this.login = user.getLogin();
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getLogin() {
        return login;
    }

    public void setLogin(String login) {
        this.login = login;
    }

    // prettier-ignore
    @Override
    public String toString() {
        return "UserDTO{" +
            "id='" + id + '\'' +
            ", login='" + login + '\'' +
            "}";
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/dto/TestEntityDTO.java
package ee.tenman.mmse.service.dto;

import jakarta.validation.constraints.NotNull;

import java.io.Serializable;
import java.time.Instant;
import java.util.Objects;

/**
 * A DTO for the {@link ee.tenman.mmse.domain.TestEntity} entity.
 */
@SuppressWarnings("common-java:DuplicatedBlocks")
public class TestEntityDTO implements Serializable {

    private Long id;

    @NotNull
    private Instant createdAt;

    private Instant updatedAt;

    private Integer score;

    private UserDTO user;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Instant getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(Instant createdAt) {
        this.createdAt = createdAt;
    }

    public Instant getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(Instant updatedAt) {
        this.updatedAt = updatedAt;
    }

    public Integer getScore() {
        return score;
    }

    public void setScore(Integer score) {
        this.score = score;
    }

    public UserDTO getUser() {
        return user;
    }

    public void setUser(UserDTO user) {
        this.user = user;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof TestEntityDTO)) {
            return false;
        }

        TestEntityDTO testEntityDTO = (TestEntityDTO) o;
        if (this.id == null) {
            return false;
        }
        return Objects.equals(this.id, testEntityDTO.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(this.id);
    }

    // prettier-ignore
    @Override
    public String toString() {
        return "TestEntityDTO{" +
            "id=" + getId() +
            ", createdAt='" + getCreatedAt() + "'" +
            ", updatedAt='" + getUpdatedAt() + "'" +
            ", score=" + getScore() +
            ", user=" + getUser() +
            "}";
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/dto/package-info.java
/**
 * Data transfer objects for rest mapping.
 */
package ee.tenman.mmse.service.dto;


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/mapper/EntityMapper.java
package ee.tenman.mmse.service.mapper;

import org.mapstruct.BeanMapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.Named;
import org.mapstruct.NullValuePropertyMappingStrategy;

import java.util.List;

/**
 * Contract for a generic dto to entity mapper.
 *
 * @param <D> - DTO type parameter.
 * @param <E> - Entity type parameter.
 */

public interface EntityMapper<D, E> {
    E toEntity(D dto);

    D toDto(E entity);

    List<E> toEntity(List<D> dtoList);

    List<D> toDto(List<E> entityList);

    @Named("partialUpdate")
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    void partialUpdate(@MappingTarget E entity, D dto);
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/mapper/TestEntityMapper.java
package ee.tenman.mmse.service.mapper;

import ee.tenman.mmse.domain.TestEntity;
import ee.tenman.mmse.domain.User;
import ee.tenman.mmse.service.dto.TestEntityDTO;
import ee.tenman.mmse.service.dto.UserDTO;
import org.mapstruct.BeanMapping;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.Named;

/**
 * Mapper for the entity {@link TestEntity} and its DTO {@link TestEntityDTO}.
 */
@Mapper(componentModel = "spring")
public interface TestEntityMapper extends EntityMapper<TestEntityDTO, TestEntity> {
    @Mapping(target = "user", source = "user", qualifiedByName = "userLogin")
    TestEntityDTO toDto(TestEntity s);

    @Named("userLogin")
    @BeanMapping(ignoreByDefault = true)
    @Mapping(target = "id", source = "id")
    @Mapping(target = "login", source = "login")
    UserDTO toDtoUserLogin(User user);
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/mapper/UserAnswerMapper.java
package ee.tenman.mmse.service.mapper;

import ee.tenman.mmse.domain.TestEntity;
import ee.tenman.mmse.domain.UserAnswer;
import ee.tenman.mmse.service.dto.TestEntityDTO;
import ee.tenman.mmse.service.dto.UserAnswerDTO;
import org.mapstruct.BeanMapping;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.Named;

/**
 * Mapper for the entity {@link UserAnswer} and its DTO {@link UserAnswerDTO}.
 */
@Mapper(componentModel = "spring")
public interface UserAnswerMapper extends EntityMapper<UserAnswerDTO, UserAnswer> {
    @Mapping(target = "testEntity", source = "testEntity", qualifiedByName = "testEntityId")
    UserAnswerDTO toDto(UserAnswer s);

    @Named("testEntityId")
    @BeanMapping(ignoreByDefault = true)
    @Mapping(target = "id", source = "id")
    TestEntityDTO toDtoTestEntityId(TestEntity testEntity);
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/mapper/UserMapper.java
package ee.tenman.mmse.service.mapper;

import ee.tenman.mmse.domain.Authority;
import ee.tenman.mmse.domain.User;
import ee.tenman.mmse.service.dto.AdminUserDTO;
import ee.tenman.mmse.service.dto.UserDTO;
import org.mapstruct.BeanMapping;
import org.mapstruct.Mapping;
import org.mapstruct.Named;
import org.springframework.stereotype.Service;

import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Mapper for the entity {@link User} and its DTO called {@link UserDTO}.
 * <p>
 * Normal mappers are generated using MapStruct, this one is hand-coded as MapStruct
 * support is still in beta, and requires a manual step with an IDE.
 */
@Service
public class UserMapper {

    public List<UserDTO> usersToUserDTOs(List<User> users) {
        return users.stream().filter(Objects::nonNull).map(this::userToUserDTO).toList();
    }

    public UserDTO userToUserDTO(User user) {
        return new UserDTO(user);
    }

    public List<AdminUserDTO> usersToAdminUserDTOs(List<User> users) {
        return users.stream().filter(Objects::nonNull).map(this::userToAdminUserDTO).toList();
    }

    public AdminUserDTO userToAdminUserDTO(User user) {
        return new AdminUserDTO(user);
    }

    public List<User> userDTOsToUsers(List<AdminUserDTO> userDTOs) {
        return userDTOs.stream().filter(Objects::nonNull).map(this::userDTOToUser).toList();
    }

    public User userDTOToUser(AdminUserDTO userDTO) {
        if (userDTO == null) {
            return null;
        } else {
            User user = new User();
            user.setId(userDTO.getId());
            user.setLogin(userDTO.getLogin());
            user.setFirstName(userDTO.getFirstName());
            user.setLastName(userDTO.getLastName());
            user.setEmail(userDTO.getEmail());
            user.setImageUrl(userDTO.getImageUrl());
            user.setActivated(userDTO.isActivated());
            user.setLangKey(userDTO.getLangKey());
            Set<Authority> authorities = this.authoritiesFromStrings(userDTO.getAuthorities());
            user.setAuthorities(authorities);
            return user;
        }
    }

    private Set<Authority> authoritiesFromStrings(Set<String> authoritiesAsString) {
        Set<Authority> authorities = new HashSet<>();

        if (authoritiesAsString != null) {
            authorities =
                authoritiesAsString
                    .stream()
                    .map(string -> {
                        Authority auth = new Authority();
                        auth.setName(string);
                        return auth;
                    })
                    .collect(Collectors.toSet());
        }

        return authorities;
    }

    public User userFromId(Long id) {
        if (id == null) {
            return null;
        }
        User user = new User();
        user.setId(id);
        return user;
    }

    @Named("id")
    @BeanMapping(ignoreByDefault = true)
    @Mapping(target = "id", source = "id")
    public UserDTO toDtoId(User user) {
        if (user == null) {
            return null;
        }
        UserDTO userDto = new UserDTO();
        userDto.setId(user.getId());
        return userDto;
    }

    @Named("idSet")
    @BeanMapping(ignoreByDefault = true)
    @Mapping(target = "id", source = "id")
    public Set<UserDTO> toDtoIdSet(Set<User> users) {
        if (users == null) {
            return Collections.emptySet();
        }

        Set<UserDTO> userSet = new HashSet<>();
        for (User userEntity : users) {
            userSet.add(this.toDtoId(userEntity));
        }

        return userSet;
    }

    @Named("login")
    @BeanMapping(ignoreByDefault = true)
    @Mapping(target = "id", source = "id")
    @Mapping(target = "login", source = "login")
    public UserDTO toDtoLogin(User user) {
        if (user == null) {
            return null;
        }
        UserDTO userDto = new UserDTO();
        userDto.setId(user.getId());
        userDto.setLogin(user.getLogin());
        return userDto;
    }

    @Named("loginSet")
    @BeanMapping(ignoreByDefault = true)
    @Mapping(target = "id", source = "id")
    @Mapping(target = "login", source = "login")
    public Set<UserDTO> toDtoLoginSet(Set<User> users) {
        if (users == null) {
            return Collections.emptySet();
        }

        Set<UserDTO> userSet = new HashSet<>();
        for (User userEntity : users) {
            userSet.add(this.toDtoLogin(userEntity));
        }

        return userSet;
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/mapper/package-info.java
/**
 * Data transfer objects mappers.
 */
package ee.tenman.mmse.service.mapper;


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/lock/LockAspect.java
package ee.tenman.mmse.service.lock;

import jakarta.annotation.Resource;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.expression.EvaluationContext;
import org.springframework.expression.Expression;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.expression.spel.support.StandardEvaluationContext;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class LockAspect {

    private final Logger log = LoggerFactory.getLogger(LockAspect.class);
    private final ExpressionParser parser = new SpelExpressionParser();
    @Resource
    private LockService lockService;

    @Around("@annotation(lock)")
    public Object aroundLockedMethod(ProceedingJoinPoint joinPoint, Lock lock) throws Throwable {
        if (lock.key().isBlank()) {
            throw new IllegalArgumentException("Lock key cannot be empty");
        }
        String lockKey = getKey(lock.key(), joinPoint);
        long timeoutMillis = lock.timeoutMillis();
        if (lock.retry()) {
            lockService.acquireLock(lockKey, timeoutMillis);
        } else {
            boolean lockAcquired = lockService.tryAcquireLock(lockKey, timeoutMillis);
            if (!lockAcquired) {
                throw new IllegalStateException("Unable to acquire lock for identifier: " + lockKey);
            }
        }
        log.debug("Lock acquired for key {} with lock key {}", lock.key(), lockKey);
        try {
            return joinPoint.proceed();
        } finally {
            lockService.releaseLock(lockKey);
            log.debug("Lock released for key {} with lock key {}", lock.key(), lockKey);
        }
    }

    private String getKey(String keyExpression, ProceedingJoinPoint joinPoint) {
        if (keyExpression.startsWith("'") && keyExpression.endsWith("'")) {
            return keyExpression.substring(1, keyExpression.length() - 1);
        }
        if (keyExpression.startsWith("#")) {
            keyExpression = keyExpression.substring(1);
        }
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        if (signature == null) {
            throw new IllegalArgumentException("No argument found in method signature");
        }

        if (!keyExpression.contains(".")) {
            throw new IllegalArgumentException("No nested key found in key expression");
        }
        Object[] args = joinPoint.getArgs();
        String[] keys = keyExpression.split("\\.");
        String nestedKey = keys[1];
        EvaluationContext context = new StandardEvaluationContext(args[0]);
        Expression expression = parser.parseExpression(nestedKey);
        return expression.getValue(context, String.class);
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/lock/LockService.java
package ee.tenman.mmse.service.lock;

import jakarta.annotation.Resource;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import java.time.Clock;
import java.util.concurrent.TimeUnit;

@Service
public class LockService {
    static final String LOCK_PREFIX = "lock:";
    private static final long DEFAULT_LOCK_WAIT_MILLIS = 5000;
    private static final long DEFAULT_LOCK_RETRY_INTERVAL_MILLIS = 30;

    @Resource
    private RedisTemplate<String, String> redisTemplate;
    @Resource
    private Clock clock;

    public void acquireLock(String identifier, long timeoutMillis) {
        long retryIntervalMillis = DEFAULT_LOCK_RETRY_INTERVAL_MILLIS;
        long startTime = clock.millis();
        long previous = 0;
        long current = 1;

        while (clock.millis() - startTime < DEFAULT_LOCK_WAIT_MILLIS) {
            if (tryAcquireLock(identifier, timeoutMillis)) {
                return;
            }
            sleep(retryIntervalMillis);
            long next = previous + current;
            previous = current;
            current = next;
            retryIntervalMillis = calculateRetryInterval(current, retryIntervalMillis, startTime, DEFAULT_LOCK_WAIT_MILLIS);
        }
        throw new IllegalStateException("Unable to acquire lock for identifier: " + identifier);
    }

    public boolean tryAcquireLock(String identifier, long timeoutMillis) {
        String lockKey = LOCK_PREFIX + identifier;
        return Boolean.TRUE.equals(redisTemplate.opsForValue().setIfAbsent(lockKey, "locked", timeoutMillis, TimeUnit.MILLISECONDS));
    }

    private void sleep(long millis) {
        try {
            TimeUnit.MILLISECONDS.sleep(millis);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new IllegalStateException("Lock acquisition interrupted", e);
        }
    }

    private long calculateRetryInterval(long current, long retryIntervalMillis, long startTime, long waitMillis) {
        return Math.min(current * retryIntervalMillis, waitMillis - (clock.millis() - startTime));
    }

    public void releaseLock(String identifier) {
        String lockKey = LOCK_PREFIX + identifier;
        redisTemplate.delete(lockKey);
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/lock/Lock.java
package ee.tenman.mmse.service.lock;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation for locking the method execution based on a specified key using Redis-based distributed locking.
 * <p>
 * The @Lock annotation is used to ensure that a method is executed exclusively
 * across multiple instances or threads for a given key value. It prevents concurrent
 * execution of the annotated method for the same key in a distributed environment.
 * <p>
 * The key is specified using the 'key' attribute, which supports the following format:
 * <ul>
 *     <li>Static string value: The key should be enclosed in single quotes (e.g., 'myLockKey').</li>
 * </ul>
 * <p>
 * Example:
 * <pre>
 * &#064;Lock(key = "'myStaticLockKey'")
 * public void processAccount() {
 *     // Method body
 * }
 * </pre>
 * In this example, the 'key' is set to "'myStaticLockKey'", which means the lock will be
 * based on the static string value "myStaticLockKey".
 * <p>
 * The @Lock annotation uses Redis as the distributed locking mechanism. It leverages the
 * atomic operations provided by Redis to acquire and release locks across multiple instances
 * or threads. The lock is acquired using the Redis 'SET' command with the 'NX' and 'EX' options,
 * ensuring that only one instance or thread can acquire the lock for a specific key at a time.
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Lock {
    /**
     * The key to lock the method execution.
     * <p>
     * The key supports the following format:
     * <ul>
     *     <li>Static string value: The key should be enclosed in single quotes (e.g., 'myLockKey').</li>
     * </ul>
     *
     * @return the key or SpEL expression for the key
     */
    String key();

    /**
     * The timeout value for the lock in milliseconds.
     * <p>
     * Specifies the maximum time the lock should be held before automatically releasing it.
     * Default value is 60,000 milliseconds (60 seconds).
     *
     * @return the timeout value in milliseconds
     */
    long timeoutMillis() default 60_000;

    /**
     * Determines whether lock acquisition should be retried if it fails.
     * <p>
     * If set to 'true' (default), the method will attempt to acquire the lock multiple times
     * before giving up. If set to 'false', the method will immediately throw an exception if
     * the lock cannot be acquired.
     *
     * @return true if lock acquisition should be retried, false otherwise
     */
    boolean retry() default true;
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/question/Question16.java
package ee.tenman.mmse.service.question;

import ee.tenman.mmse.domain.UserAnswer;
import ee.tenman.mmse.domain.enumeration.QuestionId;
import ee.tenman.mmse.domain.enumeration.QuestionType;
import org.springframework.stereotype.Component;

@Component
public class Question16 implements Question {

    private static final String QUESTION_TEXT = "16. Select the 'Paper' element, then tap 'Fold Paper in Half' to fold it. After that, drag and drop the folded paper onto the 'Floor' area.";
    private static final QuestionId QUESTION_ID = QuestionId.QUESTION_16;

    @Override
    public String getQuestionText() {
        return QUESTION_TEXT;
    }

    @Override
    public String getImage() {
        return null;
    }

    @Override
    public QuestionId getQuestionId() {
        return QUESTION_ID;
    }

    @Override
    public QuestionType getQuestionType() {
        return QuestionType.DRAG_AND_DROP;
    }

    @Override
    public int getScore(UserAnswer userAnswer) {
        if (userAnswer.getAnswerText() == null) {
            return 0;
        }

        String[] actions = userAnswer.getAnswerText().split(",");
        if (actions.length != 3) {
            return 0;
        }

        int score = 0;
        for (String action : actions) {
            if (Boolean.parseBoolean(action)) {
                score++;
            }
        }

        return score;
    }

    @Override
    public int getMaximumScore() {
        return 3;
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/question/Question5.java
package ee.tenman.mmse.service.question;

import ee.tenman.mmse.domain.UserAnswer;
import ee.tenman.mmse.domain.enumeration.QuestionId;
import ee.tenman.mmse.domain.enumeration.QuestionType;
import org.springframework.stereotype.Component;

import java.time.Month;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;

@Component
public class Question5 implements Question {

    private static final String QUESTION_TEXT = "5. What is the current season?";
    private static final String SPRING = "SPRING";
    private static final String SUMMER = "SUMMER";
    private static final String AUTUMN = "AUTUMN";
    private static final String WINTER = "WINTER";
    private static final Map<String, Set<Month>> SEASONS = Map.of(
        WINTER, Set.of(Month.DECEMBER, Month.JANUARY, Month.FEBRUARY),
        SPRING, Set.of(Month.MARCH, Month.APRIL, Month.MAY),
        SUMMER, Set.of(Month.JUNE, Month.JULY, Month.AUGUST),
        AUTUMN, Set.of(Month.SEPTEMBER, Month.OCTOBER, Month.NOVEMBER)
    );

    private static final QuestionId QUESTION_ID = QuestionId.QUESTION_5;

    @Override
    public String getQuestionText() {
        return QUESTION_TEXT;
    }

    @Override
    public QuestionId getQuestionId() {
        return QUESTION_ID;
    }

    @Override
    public QuestionType getQuestionType() {
        return QuestionType.MULTIPLE_CHOICE;
    }

    @Override
    public List<String> getAnswerOptions() {
        List<String> answerOptions = Arrays.asList(SPRING, SUMMER, AUTUMN, WINTER);
        Collections.shuffle(answerOptions);
        return answerOptions;
    }

    @Override
    public int getScore(UserAnswer userAnswer) {
        ZonedDateTime zonedDateTime = userAnswer.getCreatedAt().atZone(ZoneId.systemDefault());
        Month month = Month.from(zonedDateTime);
        String season = getSeasonFromMonth(month);

        return season.equalsIgnoreCase(userAnswer.getAnswerText()) ? 1 : 0;
    }

    String getSeasonFromMonth(Month month) {
        return SEASONS.entrySet().stream()
            .filter(entry -> entry.getValue().contains(month))
            .map(Map.Entry::getKey)
            .findFirst()
            .orElseThrow(() -> new IllegalArgumentException("Month " + month + " is not mapped to a season"));
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/question/Question9.java
package ee.tenman.mmse.service.question;

import ee.tenman.mmse.domain.UserAnswer;
import ee.tenman.mmse.domain.enumeration.QuestionId;
import ee.tenman.mmse.domain.enumeration.QuestionType;
import org.springframework.stereotype.Component;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Stream;

@Component
public class Question9 implements Question {

    private static final String QUESTION_TEXT = "9. Start with 100 and subtract 7, continue subtracting 7 from each new number for five steps.";
    private static final QuestionId QUESTION_ID = QuestionId.QUESTION_9;
    private static final List<Integer> CORRECT_ANSWERS = List.of(93, 86, 79, 72, 65);
    private List<Integer> userAnswers;

    private void populateUserAnswers(UserAnswer userAnswer) {
        userAnswers = Stream.of(userAnswer.getAnswerText().split(","))
            .filter(s -> !s.isEmpty())
            .map(Integer::parseInt)
            .toList();
    }

    @Override
    public String getQuestionText() {
        return QUESTION_TEXT;
    }

    @Override
    public QuestionId getQuestionId() {
        return QUESTION_ID;
    }

    @Override
    public QuestionType getQuestionType() {
        return QuestionType.SUBTRACTION_TASK;
    }

    public List<InputField> getAnswerOptions() {
        return List.of(
            new InputField(InputFieldType.NUMBER, 0, 99, "Result after subtracting 7 from 100"),
            new InputField(InputFieldType.NUMBER, 0, 99, "Result after subtracting 7 from the first result"),
            new InputField(InputFieldType.NUMBER, 0, 99, "Result after subtracting 7 from the second result"),
            new InputField(InputFieldType.NUMBER, 0, 99, "Result after subtracting 7 from the third result"),
            new InputField(InputFieldType.NUMBER, 0, 99, "Result after subtracting 7 from the fourth result")
        );
    }

    @Override
    public int getScore(UserAnswer userAnswer) {
        populateUserAnswers(userAnswer);

        int result = 0;
        Set<Integer> userAnswerSet = new HashSet<>(userAnswers);
        for (Integer correctAnswer : CORRECT_ANSWERS) {
            if (userAnswerSet.contains(correctAnswer)) {
                result += 1;
            }
        }

        return result;
    }

    @Override
    public int getMaximumScore() {
        return 5;
    }

}



File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/question/Question8.java
package ee.tenman.mmse.service.question;

import ee.tenman.mmse.domain.UserAnswer;
import ee.tenman.mmse.domain.enumeration.AnswerOption;
import ee.tenman.mmse.domain.enumeration.QuestionId;
import ee.tenman.mmse.domain.enumeration.QuestionType;
import org.springframework.stereotype.Component;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

@Component
public class Question8 implements Question {

    private static final String QUESTION_TEXT = "8. What is the name of the third object?";
    private static final QuestionId QUESTION_ID = QuestionId.QUESTION_8;

    @Override
    public String getQuestionText() {
        return QUESTION_TEXT;
    }

    @Override
    public String getImage() {
        return convertImageToBase64("images/ball-car-man.png");
    }

    @Override
    public QuestionId getQuestionId() {
        return QUESTION_ID;
    }

    @Override
    public QuestionType getQuestionType() {
        return QuestionType.MULTIPLE_CHOICE;
    }

    @Override
    public List<AnswerOption> getAnswerOptions() {
        List<AnswerOption> answerOptions = Arrays.asList(AnswerOption.BALL, AnswerOption.CAR, AnswerOption.MAN, AnswerOption.TREE);
        Collections.shuffle(answerOptions);
        return answerOptions;
    }

    @Override
    public int getScore(UserAnswer userAnswer) {
        return AnswerOption.valueOf(userAnswer.getAnswerText()) == AnswerOption.MAN ? 1 : 0;
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/question/Question4.java
package ee.tenman.mmse.service.question;

import ee.tenman.mmse.domain.UserAnswer;
import ee.tenman.mmse.domain.enumeration.QuestionId;
import ee.tenman.mmse.domain.enumeration.QuestionType;
import jakarta.annotation.Resource;
import org.springframework.stereotype.Component;

import java.time.Clock;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

@Component
public class Question4 implements Question {

    private static final String QUESTION_TEXT = "4. What is the current year?";
    private static final QuestionId QUESTION_ID = QuestionId.QUESTION_4;
    @Resource
    private Clock clock;

    @Override
    public String getQuestionText() {
        return QUESTION_TEXT;
    }

    @Override
    public QuestionId getQuestionId() {
        return QUESTION_ID;
    }

    @Override
    public QuestionType getQuestionType() {
        return QuestionType.MULTIPLE_CHOICE;
    }

    @Override
    public List<String> getAnswerOptions() {
        int currentYear = ZonedDateTime.now(clock).getYear();
        List<String> answerOptions = IntStream.rangeClosed(currentYear - 1, currentYear + 2)
            .mapToObj(String::valueOf)
            .collect(Collectors.toList());

        Collections.shuffle(answerOptions);

        return answerOptions;
    }

    @Override
    public int getScore(UserAnswer userAnswer) {
        ZonedDateTime zonedDateTime = userAnswer.getCreatedAt().atZone(ZoneId.systemDefault());
        int year = zonedDateTime.getYear();
        return String.valueOf(year).equals(userAnswer.getAnswerText()) ? 1 : 0;
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/question/InputField.java
package ee.tenman.mmse.service.question;

public class InputField {
    private String type;
    private int min;
    private int max;
    private String placeholder;

    public InputField(String type, int min, int max, String placeholder) {
        this.type = type;
        this.min = min;
        this.max = max;
        this.placeholder = placeholder;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public int getMin() {
        return min;
    }

    public void setMin(int min) {
        this.min = min;
    }

    public int getMax() {
        return max;
    }

    public void setMax(int max) {
        this.max = max;
    }

    public String getPlaceholder() {
        return placeholder;
    }

    public void setPlaceholder(String placeholder) {
        this.placeholder = placeholder;
    }
}



File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/question/Question10.java
package ee.tenman.mmse.service.question;

import ee.tenman.mmse.domain.UserAnswer;
import ee.tenman.mmse.domain.enumeration.QuestionId;
import ee.tenman.mmse.domain.enumeration.QuestionType;
import org.apache.commons.lang3.StringUtils;
import org.springframework.stereotype.Component;

import java.util.List;

@Component
public class Question10 implements Question {

    private static final String QUESTION_TEXT = "10. Please recall the three objects that were previously mentioned.";
    private static final QuestionId QUESTION_ID = QuestionId.QUESTION_10;
    private static final List<String> CORRECT_ANSWERS = List.of("man", "car", "ball");

    @Override
    public String getQuestionText() {
        return QUESTION_TEXT;
    }

    @Override
    public String getImage() {
        return null;
    }

    @Override
    public QuestionId getQuestionId() {
        return this.QUESTION_ID;
    }

    @Override
    public QuestionType getQuestionType() {
        return QuestionType.TEXT_INPUT;
    }

    @Override
    public int getScore(UserAnswer userAnswer) {
        int result = 0;
        for (String correctAnswer : CORRECT_ANSWERS) {
            if (StringUtils.containsIgnoreCase(userAnswer.getAnswerText(), correctAnswer)) {
                result += 1;
            }
        }

        return result;
    }

    @Override
    public int getMaximumScore() {
        return 3;
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/question/QuizService.java
package ee.tenman.mmse.service.question;

import ee.tenman.mmse.domain.TestEntity;
import ee.tenman.mmse.domain.User;
import ee.tenman.mmse.domain.UserAnswer;
import ee.tenman.mmse.domain.enumeration.QuestionId;
import ee.tenman.mmse.repository.TestEntityRepository;
import ee.tenman.mmse.repository.UserAnswerRepository;
import ee.tenman.mmse.service.UserService;
import ee.tenman.mmse.service.dto.AnswerDTO;
import ee.tenman.mmse.service.lock.Lock;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;

@Service
public class QuizService {

    private final Map<QuestionId, Question> questions;
    private final UserAnswerRepository userAnswerRepository;
    private final UserService userService;
    private final TestEntityRepository testEntityRepository;
    private final Logger log = LoggerFactory.getLogger(QuizService.class);

    @Autowired
    public QuizService(QuestionsConfig questionsConfig,
                       UserAnswerRepository userAnswerRepository,
                       UserService userService,
                       TestEntityRepository testEntityRepository) {
        this.questions = questionsConfig.getQuestions();
        this.userAnswerRepository = userAnswerRepository;
        this.userService = userService;
        this.testEntityRepository = testEntityRepository;
    }

    public Question getQuestion(QuestionId questionId) {
        return questions.get(questionId);
    }

    public int calculateScore(Long testEntityId) {
        List<UserAnswer> answers = userAnswerRepository.findByTestEntityIdOrderByCreatedAtDesc(testEntityId);
        int totalScore = 0;
        Set<QuestionId> answeredQuestions = new HashSet<>();

        for (UserAnswer userAnswer : answers) {
            Question question = questions.get(userAnswer.getQuestionId());

            if (question == null) {
                log.warn("No Question found for ID: {}", userAnswer.getQuestionId());
                continue;
            }

            if (answeredQuestions.contains(question.getQuestionId())) {
                continue;
            }

            int score = userAnswer.getScore() == null ? question.getScore(userAnswer) : userAnswer.getScore();
            userAnswer.setScore(score);
            userAnswer.setMaximumScore(question.getMaximumScore());
            totalScore += score;

            log.info("Total score: {}, Question: {}, Score: {}", totalScore, question.getQuestionId(), score);
            answeredQuestions.add(question.getQuestionId()); // mark the question as answered
        }

        userAnswerRepository.saveAll(answers);
        return totalScore;
    }


    public Question getFirstQuestion() {
        return new Question1();
    }

    @Lock(key = "#answerDTO.idempotencyKey")
    public UserAnswer saveAnswer(AnswerDTO answerDTO) {
        Optional<User> user = userService.findUserWithAuthorities();
        if (user.isEmpty()) {
            throw new RuntimeException("User not found");
        }
        TestEntity testEntity = testEntityRepository.findFirstByUserIdOrderByCreatedAtDesc(user.get().getId()).orElseGet(() -> {
            TestEntity t = new TestEntity();
            t.setUser(user.get());
            return testEntityRepository.save(t);
        });
        UserAnswer userAnswer = userAnswerRepository
            .findFirstByTestEntityIdAndQuestionIdOrderByCreatedAtDesc(testEntity.getId(), answerDTO.getQuestionId())
            .orElse(new UserAnswer());
        userAnswer.setAnswerText(answerDTO.getAnswerText());
        userAnswer.setQuestionId(answerDTO.getQuestionId());
        userAnswer.setTestEntity(testEntity);
        return userAnswerRepository.save(userAnswer);
    }

    public Question retakeTest() {
        Optional<User> user = userService.findUserWithAuthorities();
        if (user.isEmpty()) {
            throw new RuntimeException("User not found");
        }
        TestEntity testEntity = new TestEntity();
        testEntity.setUser(user.get());
        testEntityRepository.save(testEntity);
        return getFirstQuestion();
    }

    public Long createNewTestEntity() {
        User user = userService.getUserWithAuthorities();
        TestEntity testEntity = new TestEntity();
        testEntity.setUser(user);
        TestEntity savedTestEntity = testEntityRepository.save(testEntity);
        return savedTestEntity.getId();
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/question/Question3.java
package ee.tenman.mmse.service.question;

import ee.tenman.mmse.domain.UserAnswer;
import ee.tenman.mmse.domain.enumeration.QuestionId;
import ee.tenman.mmse.domain.enumeration.QuestionType;
import jakarta.annotation.Resource;
import org.springframework.stereotype.Component;

import java.time.Clock;
import java.time.Month;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

@Component
public class Question3 implements Question {

    private static final String QUESTION_TEXT = "3. What is the current month?";
    private static final QuestionId QUESTION_ID = QuestionId.QUESTION_3;

    @Resource
    private Clock clock;

    @Override
    public String getQuestionText() {
        return QUESTION_TEXT;
    }

    @Override
    public QuestionId getQuestionId() {
        return QUESTION_ID;
    }

    @Override
    public QuestionType getQuestionType() {
        return QuestionType.MULTIPLE_CHOICE;
    }

    @Override
    public List<String> getAnswerOptions() {
        Month currentMonth = Month.from(ZonedDateTime.now(clock));
        List<String> answerOptions = IntStream.rangeClosed(0, 3)
            .mapToObj(currentMonth::plus)
            .map(Month::name)
            .collect(Collectors.toList());

        Collections.shuffle(answerOptions);

        return answerOptions;
    }

    @Override
    public int getScore(UserAnswer userAnswer) {
        ZonedDateTime zonedDateTime = userAnswer.getCreatedAt().atZone(ZoneId.systemDefault());
        String month = Month.from(zonedDateTime).name();
        return month.equalsIgnoreCase(userAnswer.getAnswerText()) ? 1 : 0;
    }

}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/question/Question2.java
package ee.tenman.mmse.service.question;

import ee.tenman.mmse.domain.UserAnswer;
import ee.tenman.mmse.domain.enumeration.QuestionId;
import ee.tenman.mmse.domain.enumeration.QuestionType;
import jakarta.annotation.Resource;
import org.springframework.stereotype.Component;

import java.time.Clock;
import java.time.LocalDate;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.time.format.TextStyle;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Locale;

@Component
public class Question2 implements Question {

    private static final String QUESTION_TEXT = "2. What is the current date?";
    private static final QuestionId QUESTION_ID = QuestionId.QUESTION_2;

    @Resource
    private Clock clock;

    @Override
    public String getQuestionText() {
        return QUESTION_TEXT;
    }

    @Override
    public QuestionId getQuestionId() {
        return QUESTION_ID;
    }

    @Override
    public QuestionType getQuestionType() {
        return QuestionType.MULTIPLE_CHOICE;
    }

    @Override
    public List<String> getAnswerOptions() {
        // Get today's date
        LocalDate today = LocalDate.now(clock);

        // Format it as a string in the format '25th May 2023'
        String formattedToday = formatToOrdinalDate(today);

        // Generate three incorrect dates
        List<String> incorrectDates = Arrays.asList(
            formatToOrdinalDate(today.minus(1, ChronoUnit.MONTHS)),
            formatToOrdinalDate(today.plus(1, ChronoUnit.MONTHS)),
            formatToOrdinalDate(today.minus(1, ChronoUnit.MONTHS).plus(1, ChronoUnit.DAYS))
        );

        // Combine correct and incorrect dates into one list
        List<String> options = new ArrayList<>(incorrectDates);
        options.add(formattedToday);

        // Randomly shuffle the options
        Collections.shuffle(options);

        return options;
    }

    @Override
    public int getScore(UserAnswer userAnswer) {
        LocalDate localDate = userAnswer.getCreatedAt().atZone(ZoneId.systemDefault()).toLocalDate();
        LocalDate userAnswerDate;
        try {
            String userAnswerText = userAnswer.getAnswerText().replaceAll("(st|nd|rd|th)", "");
            userAnswerDate = LocalDate.parse(userAnswerText, DateTimeFormatter.ofPattern("d MMMM yyyy", Locale.ENGLISH));
        } catch (DateTimeParseException e) {
            return 0;
        }
        return localDate.equals(userAnswerDate) ? 1 : 0;
    }

    private String formatToOrdinalDate(LocalDate date) {
        int day = date.getDayOfMonth();
        String dayWithSuffix = day + getDayOfMonthSuffix(day);
        return dayWithSuffix + " " + date.getMonth().getDisplayName(TextStyle.FULL, Locale.ENGLISH) + " " + date.getYear();
    }

    String getDayOfMonthSuffix(final int n) {
        if (n < 1 || n > 31) throw new IllegalArgumentException("Illegal day of month");
        if (n >= 11 && n <= 13) return "th";
        return switch (n % 10) {
            case 1 -> "st";
            case 2 -> "nd";
            case 3 -> "rd";
            default -> "th";
        };
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/question/Question11.java
package ee.tenman.mmse.service.question;

import ee.tenman.mmse.domain.UserAnswer;
import ee.tenman.mmse.domain.enumeration.QuestionId;
import ee.tenman.mmse.domain.enumeration.QuestionType;
import ee.tenman.mmse.service.external.dolphin.DolphinService;
import ee.tenman.mmse.service.external.openai.NoOpenAiResponseException;
import ee.tenman.mmse.service.external.openai.OpenAiService;
import ee.tenman.mmse.service.external.similarity.SimilarityRequest;
import ee.tenman.mmse.service.external.similarity.SimilarityService;
import ee.tenman.mmse.service.external.synonym.SynonymRequest;
import ee.tenman.mmse.service.external.synonym.SynonymService;
import jakarta.annotation.Resource;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Optional;
import java.util.Set;

@Component
public class Question11 implements Question {

    private static final Logger log = LoggerFactory.getLogger(Question11.class);

    private static final String QUESTION_TEXT = "11. Please name the object shown.";
    private static final QuestionId QUESTION_ID = QuestionId.QUESTION_11;
    private static final String PENCIL = "pencil";
    private static final Set<String> ACCEPTED_ANSWERS = Set.of(
        PENCIL,
        "stylus",
        "graphite",
        "lead",
        "writing instrument",
        "scriber",
        "crayon",
        "pen"
    );
    private static final Set<String> INCORRECT_ANSWERS = Set.of(
        "paper",
        "eraser",
        "charcoal"
    );
    private static final Set<String> CORRECT_INDICATORS = Set.of(
        "yes",
        "is similar",
        "which directly relates",
        "could be considered somewhat similar",
        "It might",
        "seems to be a misspelling",
        "is close",
        "is a type",
        "closely refers"
    );

    private static final Set<String> INCORRECT_INDICATORS = Set.of(
        "no",
        "is not similar",
        "incorrect",
        "which does not directly relate",
        "could not be considered somewhat similar",
        "It might not",
        "does not seem to be a misspelling",
        "is not close",
        "is not a type",
        "does not closely refer",
        "unable",
        "impossible"
    );

    private static final String POSITIVE = "positive";
    private static final String NEGATIVE = "negative";
    private static final String NO_RESPONSE = "No response";

    @Resource
    OpenAiService openAiService;

    @Resource
    SimilarityService similarityService;

    @Resource
    SynonymService synonymService;

    @Resource
    DolphinService dolphinService;

    @Override
    public String getQuestionText() {
        return QUESTION_TEXT;
    }

    @Override
    public String getImage() {
        return convertImageToBase64("images/pencil.png");
    }

    @Override
    public QuestionId getQuestionId() {
        return QUESTION_ID;
    }

    @Override
    public QuestionType getQuestionType() {
        return QuestionType.TEXT_INPUT;
    }

    @Override
    public List<String> getAnswerOptions() {
        return List.of();
    }

    @Override
    public int getScore(UserAnswer userAnswer) {
        String answerText = userAnswer.getAnswerText();

        if (StringUtils.isBlank(answerText)) {
            log.debug("Received blank answer.");
            return 0;
        }

        answerText = StringUtils.trim(answerText).replaceAll("[^a-zA-Z0-9\\s]", "").toLowerCase();

        if (!containsWordWithThreeLetters(answerText)) {
            log.debug("Answer '{}' does not contain any word with at least three letters.", answerText);
            return 0;
        }

        if (isAcceptedAnswer(answerText)) {
            log.debug("Answer '{}' is in the list of accepted answers.", answerText);
            return 1;
        }

        if (INCORRECT_ANSWERS.contains(answerText)) {
            log.debug("Answer '{}' is in the list of incorrect answers.", answerText);
            return 0;
        }

        if (isSynonym(answerText)) {
            log.debug("Answer '{}' is a synonym to one of the accepted answers.", answerText);
            return 1;
        }

        if (isSimilar(answerText)) {
            log.debug("Answer '{}' is similar to one of the accepted answers.", answerText);
            return 1;
        }

        if (isDolphinSimilar(answerText)) {
            log.debug("Answer '{}' is similar to one of the accepted answers.", answerText);
            return 1;
        }
        Optional<String> openAiResponse = checkWithOpenAiService(answerText);
        return evaluateOpenAiResponse(answerText, openAiResponse);
    }

    private boolean isDolphinSimilar(String answerText) {
        String prompt = prepareAiPrompt(answerText);
        String response = dolphinService.checkWithDolphinService(prompt);
        log.debug("DolphinAI Service Response: '{}'", response);
        if (CORRECT_INDICATORS.stream().anyMatch(response::contains)) {
            log.debug("DolphinAI Service deemed answer '{}' as correct. Response: '{}'", answerText, response);
            return true;
        }
        log.debug("DolphinAI Service deemed answer '{}' as incorrect. Response: '{}'", answerText, response);
        return false;
    }

    private boolean isSynonym(String answerText) {
        return synonymService.isSynonym(new SynonymRequest(answerText, PENCIL));
    }

    private boolean isSimilar(String answerText) {
        return similarityService.isSimilar(new SimilarityRequest(answerText, PENCIL));
    }

    private int evaluateOpenAiResponse(String answerText, Optional<String> responseText) {
        if (responseText.isEmpty()) {
            log.debug("Answer '{}' was not recognized as correct by OpenAI Service. Response: '{}'", answerText, Question11.NO_RESPONSE);
            return 0;
        }

        String response = responseText.get().toLowerCase();
        log.debug("OpenAI Service Response: '{}'", response);

        if (CORRECT_INDICATORS.stream().anyMatch(response::contains)) {
            log.debug("OpenAI Service deemed answer '{}' as correct. Response: '{}'", answerText, response);
            return 1;
        }

        if (INCORRECT_INDICATORS.stream().anyMatch(response::contains)) {
            log.debug("OpenAI Service deemed answer '{}' as incorrect. Response: '{}'", answerText, response);
            return 0;
        }

        log.debug("OpenAI Service deemed answer '{}' as incorrect. Response: '{}'", answerText, response);
        return performSecondaryOpenAiCheck(response);
    }

    private boolean isAcceptedAnswer(String answerText) {
        return ACCEPTED_ANSWERS.contains(StringUtils.lowerCase(answerText));
    }

    private Optional<String> checkWithOpenAiService(String answerText) {
        String prompt = prepareAiPrompt(answerText);

        Optional<String> response = openAiService.askQuestion(prompt);
        if (response.isEmpty()) {
            log.debug("Answer '{}' was not recognized as correct by OpenAI Service. Response: '{}'", answerText, NO_RESPONSE);
            throw new NoOpenAiResponseException("OpenAI Service returned no response");
        }

        String openAiResponse = response.get().toLowerCase();
        log.debug("OpenAI Response: {}", openAiResponse);

        return response;
    }

    private String prepareAiPrompt(String answerText) {
        String allAnswers = String.join(", ", ACCEPTED_ANSWERS);
        return String.format("Is the phrase \"%s\" close to or misspelled in meaning to any of these: %s? Answer only yes/no", answerText,
            allAnswers);
    }

    private int performSecondaryOpenAiCheck(String openAiResponse) {
        Optional<String> response = openAiService.askQuestion(
            String.format("Is this phrase %s %s or %s?", openAiResponse, POSITIVE, NEGATIVE)
        );

        if (response.isPresent() && response.get().toLowerCase().contains(POSITIVE)) {
            return 1;
        }
        return 0;
    }

    private boolean containsWordWithThreeLetters(String answerText) {
        String[] words = answerText.split("\\s+");
        for (String word : words) {
            if (word.length() >= 3) {
                return true;
            }
        }
        return false;
    }

}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/question/QuestionsConfig.java
package ee.tenman.mmse.service.question;

import ee.tenman.mmse.domain.enumeration.QuestionId;
import jakarta.annotation.PostConstruct;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

@Component
public class QuestionsConfig {

    private Map<QuestionId, Question> questions;

    private final List<Question> questionBeans;

    public QuestionsConfig(List<Question> questionBeans) {
        this.questionBeans = questionBeans;
    }

    @PostConstruct
    public void init() {
        questions = questionBeans.stream().collect(Collectors.toMap(Question::getQuestionId, Function.identity()));
    }

    public Map<QuestionId, Question> getQuestions() {
        return questions;
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/question/Question.java
package ee.tenman.mmse.service.question;

import ee.tenman.mmse.domain.UserAnswer;
import ee.tenman.mmse.domain.enumeration.QuestionId;
import ee.tenman.mmse.domain.enumeration.QuestionType;
import org.apache.commons.compress.utils.IOUtils;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.Base64;
import java.util.Collection;
import java.util.List;

public interface Question {
    String getQuestionText();

    default String getImage() {
        return null;
    }

    QuestionId getQuestionId();

    QuestionType getQuestionType();

    default Collection<?> getAnswerOptions() {
        return List.of();
    }

    default String convertImageToBase64(String imagePath) {
        try {
            ClassLoader classLoader = getClass().getClassLoader();
            InputStream inputStream = classLoader.getResourceAsStream(imagePath);
            if (inputStream == null) {
                throw new FileNotFoundException("File not found " + imagePath);
            }
            byte[] imageBytes = IOUtils.toByteArray(inputStream);
            return Base64.getEncoder().encodeToString(imageBytes);
        } catch (IOException ignored) {
        }
        return null;
    }

    int getScore(UserAnswer userAnswer);

    default int getMaximumScore() {
        return 1;
    };

}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/question/Question1.java
package ee.tenman.mmse.service.question;

import ee.tenman.mmse.domain.UserAnswer;
import ee.tenman.mmse.domain.enumeration.QuestionId;
import ee.tenman.mmse.domain.enumeration.QuestionType;
import ee.tenman.mmse.service.external.dolphin.DolphinService;
import ee.tenman.mmse.service.external.minio.StorageService;
import ee.tenman.mmse.service.external.similarity.SimilarityRequest;
import ee.tenman.mmse.service.external.similarity.SimilarityService;
import ee.tenman.mmse.service.external.synonym.SynonymRequest;
import ee.tenman.mmse.service.external.synonym.SynonymService;
import ee.tenman.mmse.service.external.transcription.ByteArrayMultipartFile;
import ee.tenman.mmse.service.external.transcription.TranscriptionRequest;
import ee.tenman.mmse.service.external.transcription.TranscriptionResponse;
import ee.tenman.mmse.service.external.transcription.TranscriptionService;
import jakarta.annotation.Resource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.multipart.MultipartFile;

import java.util.Set;

import static ee.tenman.mmse.service.external.transcription.TranscriptionRequest.ModelName.FACEBOOK_WAV_2_VEC_2_LARGE_960_H;

@Component
public class Question1 implements Question {

    private static final Logger log = LoggerFactory.getLogger(Question1.class);

    private static final QuestionId QUESTION_ID = QuestionId.QUESTION_1;

    private static final String SENTENCE = "No ifs, ands, or buts";
    private static final String QUESTION_TEXT = String.format("1. Press the record button and repeat the following phrase: '%s'", SENTENCE);

    private static final Set<String> CORRECT_INDICATORS = Set.of(
        "yes",
        "is similar",
        "which directly relates",
        "could be considered somewhat similar",
        "It might",
        "seems to be a misspelling",
        "is close",
        "is a type",
        "closely refers"
    );
    @Resource
    SimilarityService similarityService;
    @Resource
    SynonymService synonymService;
    @Resource
    DolphinService dolphinService;
    @Resource
    private StorageService storageService;
    @Resource
    private TranscriptionService transcriptionService;


    @Override
    public String getQuestionText() {
        return QUESTION_TEXT;
    }

    @Override
    public String getImage() {
        return null;
    }

    @Override
    public QuestionId getQuestionId() {
        return QUESTION_ID;
    }

    @Override
    public QuestionType getQuestionType() {
        return QuestionType.VOICE_INPUT;
    }

    @Override
    public int getScore(UserAnswer userAnswer) {
        String answerText = processVoiceInput(userAnswer.getAnswerText());
        if (isSynonym(answerText)) {
            log.debug("Answer '{}' is a synonym to one of the accepted answers.", answerText);
            return 1;
        }
        if (isSimilar(answerText)) {
            log.debug("Answer '{}' is similar to one of the accepted answers.", answerText);
            return 1;
        }
        if (isDolphinSimilar(answerText)) {
            log.debug("Answer '{}' is similar to one of the accepted answers.", answerText);
            return 1;
        } else {
            log.debug("User did not repeat the phrase correctly.");
            return 0;
        }
    }

    private String processVoiceInput(String fileName) {
        byte[] bytes = storageService.downloadFile(fileName);
        MultipartFile multipartFile = new ByteArrayMultipartFile(fileName, bytes);
        TranscriptionRequest transcriptionRequest = new TranscriptionRequest(multipartFile, FACEBOOK_WAV_2_VEC_2_LARGE_960_H);
        TranscriptionResponse transcriptionResponse = transcriptionService.transcribe(transcriptionRequest);
        return transcriptionResponse.getTranscription();
    }

    private boolean isSynonym(String answerText) {
        return synonymService.isSynonym(new SynonymRequest(answerText, SENTENCE));
    }

    private boolean isSimilar(String answerText) {
        return similarityService.isSimilar(new SimilarityRequest(answerText, SENTENCE));
    }

    private boolean isDolphinSimilar(String answerText) {
        String prompt = prepareAiPrompt(answerText);
        String response = dolphinService.checkWithDolphinService(prompt);
        log.debug("DolphinAI Service Response: '{}'", response);
        if (CORRECT_INDICATORS.stream().anyMatch(response::contains)) {
            log.debug("DolphinAI Service deemed answer '{}' as correct. Response: '{}'", answerText, response);
            return true;
        }
        log.debug("DolphinAI Service deemed answer '{}' as incorrect. Response: '{}'", answerText, response);
        return false;
    }

    private String prepareAiPrompt(String answerText) {
        return String.format("Is the phrase \"%s\" close to or misspelled in meaning to this: %s? Answer only yes/no",
            answerText, SENTENCE);
    }

}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/question/Question12.java
package ee.tenman.mmse.service.question;

import ee.tenman.mmse.domain.UserAnswer;
import ee.tenman.mmse.domain.enumeration.QuestionId;
import ee.tenman.mmse.domain.enumeration.QuestionType;
import ee.tenman.mmse.service.external.openai.NoOpenAiResponseException;
import ee.tenman.mmse.service.external.openai.OpenAiService;
import jakarta.annotation.Resource;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Optional;
import java.util.Set;

@Component
public class Question12 implements Question {

    private static final Logger log = LoggerFactory.getLogger(Question12.class);

    private static final String QUESTION_TEXT = "12. Please name the object shown.";
    private static final QuestionId QUESTION_ID = QuestionId.QUESTION_12;
    private static final Set<String> ACCEPTED_ANSWERS = Set.of(
        "watch",
        "timepiece",
        "wristwatch",
        "chronometer",
        "clock",
        "digital watch",
        "analog watch",
        "quartz watch",
        "smartwatch",
        "pocket watch",
        "stopwatch",
        "diver's watch",
        "chronograph",
        "sports watch",
        "tactical watch",
        "fitness watch",
        "hand watch",
        "automatic watch",
        "mechanical watch",
        "luxury watch",
        "dress watch",
        "pilot watch",
        "field watch",
        "solar watch",
        "atomic watch",
        "LED watch",
        "LCD watch"
    );

    private static final Set<String> INCORRECT_ANSWERS = Set.of(
        "bracelet",
        "bangle",
        "cufflink",
        "ring",
        "necklace",
        "pendant",
        "chain",
        "smart band",
        "fitness tracker",
        "anklet",
        "charm",
        "brooch",
        "earring",
        "sundial",
        "timer",
        "hourglass",
        "metronome",
        "compass",
        "thermometer",
        "barometer",
        "altimeter",
        "speedometer",
        "odometer",
        "calculator",
        "mobile phone"
    );
    private static final Set<String> CORRECT_INDICATORS = Set.of(
        "yes",
        "is similar",
        "which directly relates",
        "could be considered somewhat similar",
        "It might",
        "seems to be a misspelling",
        "is close",
        "is a type",
        "closely refers"
    );

    private static final Set<String> INCORRECT_INDICATORS = Set.of(
        "no",
        "is not similar",
        "incorrect",
        "which does not directly relate",
        "could not be considered somewhat similar",
        "It might not",
        "does not seem to be a misspelling",
        "is not close",
        "is not a type",
        "does not closely refer",
        "unable",
        "impossible"
    );

    private static final String POSITIVE = "positive";
    private static final String NEGATIVE = "negative";
    private static final String NO_RESPONSE = "No response";

    @Resource
    OpenAiService openAiService;

    @Override
    public String getQuestionText() {
        return QUESTION_TEXT;
    }

    @Override
    public String getImage() {
        return convertImageToBase64("images/watch.png");
    }

    @Override
    public QuestionId getQuestionId() {
        return QUESTION_ID;
    }

    @Override
    public QuestionType getQuestionType() {
        return QuestionType.TEXT_INPUT;
    }

    @Override
    public List<String> getAnswerOptions() {
        return List.of();
    }

    @Override
    public int getScore(UserAnswer userAnswer) {
        String answerText = userAnswer.getAnswerText();

        if (StringUtils.isBlank(answerText)) {
            log.debug("Received blank answer.");
            return 0;
        }

        answerText = StringUtils.trim(answerText).replaceAll("[^a-zA-Z0-9\\s]", "");

        if (!containsWordWithThreeLetters(answerText)) {
            log.debug("Answer '{}' does not contain any word with at least three letters.", answerText);
            return 0;
        }

        if (isAcceptedAnswer(answerText)) {
            log.debug("Answer '{}' is in the list of accepted answers.", answerText);
            return 1;
        }

        return evaluateOpenAiResponse(answerText);
    }

    private int evaluateOpenAiResponse(String answerText) {
        Optional<String> openAiResponse = checkWithOpenAiService(answerText);
        if (openAiResponse.isEmpty()) {
            log.debug("Answer '{}' was not recognized as correct by OpenAI Service. Response: '{}'", answerText, Question12.NO_RESPONSE);
            return 0;
        }

        String response = openAiResponse.get().toLowerCase();
        log.debug("OpenAI Service Response: '{}'", response);

        if (CORRECT_INDICATORS.stream().anyMatch(response::contains)) {
            log.debug("OpenAI Service deemed answer '{}' as correct. Response: '{}'", answerText, response);
            return 1;
        }

        if (INCORRECT_INDICATORS.stream().anyMatch(response::contains)) {
            log.debug("OpenAI Service deemed answer '{}' as incorrect. Response: '{}'", answerText, response);
            return 0;
        }

        log.debug("OpenAI Service deemed answer '{}' as incorrect. Response: '{}'", answerText, response);
        return performSecondaryOpenAiCheck(response);
    }

    private boolean isAcceptedAnswer(String answerText) {
        return ACCEPTED_ANSWERS.contains(StringUtils.lowerCase(answerText));
    }

    private Optional<String> checkWithOpenAiService(String answerText) {
        String prompt = prepareOpenAiPrompt(answerText);

        Optional<String> response = openAiService.askQuestion(prompt);
        if (response.isEmpty()) {
            log.debug("Answer '{}' was not recognized as correct by OpenAI Service. Response: '{}'", answerText, NO_RESPONSE);
            throw new NoOpenAiResponseException("OpenAI Service returned no response");
        }

        String openAiResponse = response.get().toLowerCase();
        log.debug("OpenAI Response: {}", openAiResponse);

        return response;
    }

    private String prepareOpenAiPrompt(String answerText) {
        String allAnswers = String.join(", ", ACCEPTED_ANSWERS);
        String allIncorrectAnswers = String.join(", ", INCORRECT_ANSWERS);
        return String.format("Is the phrase \"%s\" close to or misspelled in meaning to any of these: %s? And it is not close to or misspelled in meaning to any of these: %s?. Please answer as 'yes' or 'no'", answerText,
            allAnswers, allIncorrectAnswers);
    }

    private int performSecondaryOpenAiCheck(String openAiResponse) {
        Optional<String> response = openAiService.askQuestion(
            String.format("Is this phrase %s %s or %s?", openAiResponse, POSITIVE, NEGATIVE)
        );

        if (response.isPresent() && response.get().toLowerCase().contains(POSITIVE)) {
            return 1;
        }
        return 0;
    }

    private boolean containsWordWithThreeLetters(String answerText) {
        String[] words = answerText.split("\\s+");
        for (String word : words) {
            if (word.length() >= 5) {
                return true;
            }
        }
        return false;
    }

}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/question/Question13.java
package ee.tenman.mmse.service.question;

import ee.tenman.mmse.domain.UserAnswer;
import ee.tenman.mmse.domain.enumeration.QuestionId;
import ee.tenman.mmse.domain.enumeration.QuestionType;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

@Component
public class Question13 implements Question {

    private static final Logger log = LoggerFactory.getLogger(Question13.class);

    private static final QuestionId QUESTION_ID = QuestionId.QUESTION_13;
    private static final String QUESTION_TEXT = "13. Please type the word 'agree' into the text box to confirm that you have read and understood this command.";
    private static final String EXPECTED_CONFIRMATION = "agree";


    @Override
    public String getQuestionText() {
        return QUESTION_TEXT;
    }

    @Override
    public String getImage() {
        return null;
    }

    @Override
    public QuestionId getQuestionId() {
        return QUESTION_ID;
    }

    @Override
    public QuestionType getQuestionType() {
        return QuestionType.TEXT_INPUT;
    }

    @Override
    public int getScore(UserAnswer userAnswer) {
        String answerText = userAnswer.getAnswerText();

        if (StringUtils.isBlank(answerText)) {
            log.debug("Received blank answer.");
            return 0;
        }

        answerText = StringUtils.trim(answerText).toLowerCase();

        // Check if the user typed the expected confirmation word
        if (EXPECTED_CONFIRMATION.equals(answerText)) {
            log.debug("User typed the expected confirmation word.");
            return 1;
        } else {
            log.debug("User did not type the expected confirmation word.");
            return 0;
        }
    }

}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/question/InputFieldType.java
package ee.tenman.mmse.service.question;

public interface InputFieldType {
    String NUMBER = "number";
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/question/Question7.java
package ee.tenman.mmse.service.question;

import ee.tenman.mmse.domain.UserAnswer;
import ee.tenman.mmse.domain.enumeration.AnswerOption;
import ee.tenman.mmse.domain.enumeration.QuestionId;
import ee.tenman.mmse.domain.enumeration.QuestionType;
import org.springframework.stereotype.Component;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

@Component
public class Question7 implements Question {

    private static final String QUESTION_TEXT = "7. What is the name of the second object?";
    private static final QuestionId QUESTION_ID = QuestionId.QUESTION_7;

    @Override
    public String getQuestionText() {
        return QUESTION_TEXT;
    }

    @Override
    public String getImage() {
        return convertImageToBase64("images/ball-car-man.png");
    }

    @Override
    public QuestionId getQuestionId() {
        return QUESTION_ID;
    }

    @Override
    public QuestionType getQuestionType() {
        return QuestionType.MULTIPLE_CHOICE;
    }

    @Override
    public List<AnswerOption> getAnswerOptions() {
        List<AnswerOption> answerOptions = Arrays.asList(AnswerOption.BALL, AnswerOption.CAR, AnswerOption.MAN, AnswerOption.TREE);
        Collections.shuffle(answerOptions);
        return answerOptions;
    }

    @Override
    public int getScore(UserAnswer userAnswer) {
        return AnswerOption.valueOf(userAnswer.getAnswerText()) == AnswerOption.CAR ? 1 : 0;
    }

}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/question/Question14.java
package ee.tenman.mmse.service.question;

import ee.tenman.mmse.domain.UserAnswer;
import ee.tenman.mmse.domain.enumeration.QuestionId;
import ee.tenman.mmse.domain.enumeration.QuestionType;
import ee.tenman.mmse.service.external.prediction.PredictionService;
import jakarta.annotation.Resource;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

@Component
public class Question14 implements Question {

    private static final Logger log = LoggerFactory.getLogger(Question14.class);

    private static final QuestionId QUESTION_ID = QuestionId.QUESTION_14;
    private static final String QUESTION_TEXT = "14. Write a complete sentence about something you do every day.";

    @Resource
    private PredictionService predictionService;

    @Override
    public String getQuestionText() {
        return QUESTION_TEXT;
    }

    @Override
    public String getImage() {
        return null;
    }

    @Override
    public QuestionId getQuestionId() {
        return QUESTION_ID;
    }

    @Override
    public QuestionType getQuestionType() {
        return QuestionType.TEXT_INPUT;
    }

    @Override
    public int getScore(UserAnswer userAnswer) {
        if (StringUtils.isBlank(userAnswer.getAnswerText())) {
            log.debug("Received blank answer.");
            return 0;
        }

        return predictionService.isGrammaticallyCorrect(userAnswer.getAnswerText()) ? 1 : 0;
    }


}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/question/Question15.java
package ee.tenman.mmse.service.question;

import ee.tenman.mmse.domain.UserAnswer;
import ee.tenman.mmse.domain.enumeration.QuestionId;
import ee.tenman.mmse.domain.enumeration.QuestionType;
import org.springframework.stereotype.Component;

import java.time.DayOfWeek;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Component
public class Question15 implements Question {

    private static final String QUESTION_TEXT = "15. What is the current day of the week?";
    private static final QuestionId QUESTION_ID = QuestionId.QUESTION_15;

    @Override
    public String getQuestionText() {
        return QUESTION_TEXT;
    }

    @Override
    public QuestionId getQuestionId() {
        return QUESTION_ID;
    }

    @Override
    public QuestionType getQuestionType() {
        return QuestionType.MULTIPLE_CHOICE;
    }

    @Override
    public List<String> getAnswerOptions() {
        // Get the current day of the week
        ZonedDateTime zonedDateTime = ZonedDateTime.now(ZoneId.systemDefault());
        String currentDayOfWeek = DayOfWeek.from(zonedDateTime).name();

        // Prepare a list of three random days excluding the current day
        List<String> daysOfWeek = Stream.of(DayOfWeek.values()).map(DayOfWeek::name).collect(Collectors.toList());
        daysOfWeek.remove(currentDayOfWeek);
        Collections.shuffle(daysOfWeek);
        List<String> answerOptions = daysOfWeek.subList(0, 3);

        // Add the current day to the list and shuffle again
        answerOptions.add(currentDayOfWeek);
        Collections.shuffle(answerOptions);

        return answerOptions;
    }

    @Override
    public int getScore(UserAnswer userAnswer) {
        ZonedDateTime zonedDateTime = userAnswer.getCreatedAt().atZone(ZoneId.systemDefault());
        String dayOfWeek = DayOfWeek.from(zonedDateTime).name();
        return dayOfWeek.equalsIgnoreCase(userAnswer.getAnswerText()) ? 1 : 0;
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/question/Question6.java
package ee.tenman.mmse.service.question;

import ee.tenman.mmse.domain.UserAnswer;
import ee.tenman.mmse.domain.enumeration.AnswerOption;
import ee.tenman.mmse.domain.enumeration.QuestionId;
import ee.tenman.mmse.domain.enumeration.QuestionType;
import org.springframework.stereotype.Component;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

@Component
public class Question6 implements Question {

    private static final String QUESTION_TEXT = "6. Please look at these three images. What is the name of the first object?";
    private static final QuestionId QUESTION_ID = QuestionId.QUESTION_6;

    @Override
    public String getQuestionText() {
        return QUESTION_TEXT;
    }

    @Override
    public String getImage() {
        return convertImageToBase64("images/ball-car-man.png");
    }

    @Override
    public QuestionId getQuestionId() {
        return QUESTION_ID;
    }

    @Override
    public QuestionType getQuestionType() {
        return QuestionType.MULTIPLE_CHOICE;
    }

    @Override
    public List<AnswerOption> getAnswerOptions() {
        List<AnswerOption> answerOptions = Arrays.asList(AnswerOption.BALL, AnswerOption.CAR, AnswerOption.MAN, AnswerOption.TREE);
        Collections.shuffle(answerOptions);
        return answerOptions;
    }

    @Override
    public int getScore(UserAnswer userAnswer) {
        return AnswerOption.valueOf(userAnswer.getAnswerText()) == AnswerOption.BALL ? 1 : 0;
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/synonym/SynonymRequest.java
package ee.tenman.mmse.service.external.synonym;

public class SynonymRequest {
    private String text1;
    private String text2;

    public SynonymRequest() {
    }

    public SynonymRequest(String text1, String sentence2) {
        this.text1 = text1;
        this.text2 = sentence2;
    }

    public String getText1() {
        return text1;
    }

    public void setText1(String text1) {
        this.text1 = text1;
    }

    public String getText2() {
        return text2;
    }

    public void setText2(String text2) {
        this.text2 = text2;
    }

    @Override
    public String toString() {
        return "SynonymRequest{" +
            "text1='" + text1 + '\'' +
            ", text2='" + text2 + '\'' +
            '}';
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/synonym/SynonymResponse.java
package ee.tenman.mmse.service.external.synonym;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;

public class SynonymResponse {

    private double similarityScore;

    @JsonCreator
    public SynonymResponse(@JsonProperty("similarity_score") double similarityScore) {
        this.similarityScore = similarityScore;
    }

    public double getSimilarityScore() {
        return similarityScore;
    }

    public void setSimilarityScore(double similarityScore) {
        this.similarityScore = similarityScore;
    }

    @Override
    public String toString() {
        return "SynonymResponse{" +
            "similarityScore=" + similarityScore +
            '}';
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/synonym/SynonymClient.java
package ee.tenman.mmse.service.external.synonym;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

@FeignClient(name = "synonymClient", url = "http://127.0.0.1:61238")
public interface SynonymClient {

    @PostMapping("/synonym")
    SynonymResponse synonym(@RequestBody SynonymRequest request);

}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/synonym/SynonymService.java
package ee.tenman.mmse.service.external.synonym;

import jakarta.annotation.Resource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;


@Service
public class SynonymService {

    private static final Logger log = LoggerFactory.getLogger(SynonymService.class);

    private static final double SYNONYM_THRESHOLD = 0.6;

    @Resource
    private SynonymClient synonymClient;

    public boolean isSynonym(SynonymRequest request) {
        log.info("Checking synonym: {}", request);
        SynonymResponse response = synonymClient.synonym(request);
        log.info("Synonym response: {}", response);
        return response.getSimilarityScore() >= SYNONYM_THRESHOLD;
    }

}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/transcription/TranscriptionResponse.java
package ee.tenman.mmse.service.external.transcription;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;

public class TranscriptionResponse {
    private String fileName;
    private String transcription;
    private double durationSeconds;

    @JsonCreator
    public TranscriptionResponse(
        @JsonProperty("file_name") String fileName,
        @JsonProperty("transcription") String transcription,
        @JsonProperty("duration_seconds") double durationSeconds
    ) {
        this.fileName = fileName;
        this.transcription = transcription;
        this.durationSeconds = durationSeconds;
    }

    public String getFileName() {
        return fileName;
    }

    public void setFileName(String fileName) {
        this.fileName = fileName;
    }

    public String getTranscription() {
        return transcription;
    }

    public void setTranscription(String transcription) {
        this.transcription = transcription;
    }

    public double getDurationSeconds() {
        return durationSeconds;
    }

    public void setDurationSeconds(double durationSeconds) {
        this.durationSeconds = durationSeconds;
    }

    @Override
    public String toString() {
        return "TranscriptionResponse{" +
            "fileName='" + fileName + '\'' +
            ", transcription='" + transcription + '\'' +
            ", durationSeconds=" + durationSeconds +
            '}';
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/transcription/TranscriptionRequest.java
package ee.tenman.mmse.service.external.transcription;

import org.springframework.web.multipart.MultipartFile;

public class TranscriptionRequest {
    private final MultipartFile file;
    private final ModelName modelName;
    private boolean convertMp3;

    public TranscriptionRequest(MultipartFile file, ModelName modelName, boolean convertMp3) {
        this.file = file;
        this.modelName = modelName;
        this.convertMp3 = convertMp3;
    }

    public TranscriptionRequest(MultipartFile file, ModelName modelName) {
        this.file = file;
        this.modelName = modelName;
    }

    public MultipartFile getFile() {
        return file;
    }

    public boolean isConvertMp3() {
        return convertMp3;
    }

    public ModelName getModelName() {
        return modelName;
    }

    @Override
    public String toString() {
        return "TranscriptionRequest{" +
            "file=" + file +
            ", modelName='" + modelName + '\'' +
            ", convertMp3=" + convertMp3 +
            '}';
    }

    public enum ModelName {
        FACEBOOK_WAV_2_VEC_2_LARGE_960_H("facebook/wav2vec2-large-960h"),
        FACEBOOK_WAV_2_VEC_2_LARGE_ROBUST_FT_LIBRI_960_H("facebook/wav2vec2-large-robust-ft-libri-960h");

        private final String value;

        ModelName(String value) {
            this.value = value;
        }

        public String getValue() {
            return value;
        }
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/transcription/ByteArrayMultipartFile.java
package ee.tenman.mmse.service.external.transcription;

import org.springframework.web.multipart.MultipartFile;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;

public class ByteArrayMultipartFile implements MultipartFile {
    private final byte[] bytes;
    private final String name;

    public ByteArrayMultipartFile(String name, byte[] bytes) {
        this.name = name;
        this.bytes = bytes;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public String getOriginalFilename() {
        return name;
    }

    @Override
    public String getContentType() {
        return "audio/webm";
    }

    @Override
    public boolean isEmpty() {
        return bytes == null || bytes.length == 0;
    }

    @Override
    public long getSize() {
        return bytes.length;
    }

    @Override
    public byte[] getBytes() throws IOException {
        return bytes;
    }

    @Override
    public java.io.InputStream getInputStream() throws IOException {
        return new ByteArrayInputStream(bytes);
    }

    @Override
    public void transferTo(File dest) throws IOException, IllegalStateException {
        try (FileOutputStream fos = new FileOutputStream(dest)) {
            fos.write(bytes);
        }
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/transcription/TranscriptionClient.java
package ee.tenman.mmse.service.external.transcription;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.multipart.MultipartFile;

@FeignClient(name = "transcriptionClient", url = "http://127.0.0.1:61235")
public interface TranscriptionClient {
    @PostMapping(value = "/transcribe", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    TranscriptionResponse transcribe(@RequestPart("file") MultipartFile file,
                                     @RequestPart("model_name") String modelName,
                                     @RequestPart("convert_mp3") boolean convertMp3);
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/transcription/TranscriptionService.java
package ee.tenman.mmse.service.external.transcription;

import jakarta.annotation.Resource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

@Service
public class TranscriptionService {
    private static final Logger log = LoggerFactory.getLogger(TranscriptionService.class);

    @Resource
    private TranscriptionClient transcriptionClient;

    public TranscriptionResponse transcribe(TranscriptionRequest request) {
        log.info("Transcribing audio file: {}", request.getFile().getOriginalFilename());
        return transcriptionClient.transcribe(request.getFile(), request.getModelName().getValue(), request.isConvertMp3());
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/dolphin/DolphinResponse.java
package ee.tenman.mmse.service.external.dolphin;

import com.fasterxml.jackson.annotation.JsonProperty;

import java.time.Instant;
import java.util.List;

public class DolphinResponse {
    private String model;
    @JsonProperty("created_at")
    private Instant createdAt;
    private String response;
    private boolean done;
    private List<Integer> context;
    @JsonProperty("total_duration")
    private long totalDuration;
    @JsonProperty("load_duration")
    private long loadDuration;
    @JsonProperty("prompt_eval_count")
    private int promptEvalCount;
    @JsonProperty("prompt_eval_duration")
    private long promptEvalDuration;
    @JsonProperty("eval_count")
    private int evalCount;
    @JsonProperty("eval_duration")
    private long evalDuration;

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public Instant getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(Instant createdAt) {
        this.createdAt = createdAt;
    }

    public String getResponse() {
        return response;
    }

    public void setResponse(String response) {
        this.response = response;
    }

    public boolean isDone() {
        return done;
    }

    public void setDone(boolean done) {
        this.done = done;
    }

    public List<Integer> getContext() {
        return context;
    }

    public void setContext(List<Integer> context) {
        this.context = context;
    }

    public long getTotalDuration() {
        return totalDuration;
    }

    public void setTotalDuration(long totalDuration) {
        this.totalDuration = totalDuration;
    }

    public long getLoadDuration() {
        return loadDuration;
    }

    public void setLoadDuration(long loadDuration) {
        this.loadDuration = loadDuration;
    }

    public int getPromptEvalCount() {
        return promptEvalCount;
    }

    public void setPromptEvalCount(int promptEvalCount) {
        this.promptEvalCount = promptEvalCount;
    }

    public long getPromptEvalDuration() {
        return promptEvalDuration;
    }

    public void setPromptEvalDuration(long promptEvalDuration) {
        this.promptEvalDuration = promptEvalDuration;
    }

    public int getEvalCount() {
        return evalCount;
    }

    public void setEvalCount(int evalCount) {
        this.evalCount = evalCount;
    }

    public long getEvalDuration() {
        return evalDuration;
    }

    public void setEvalDuration(long evalDuration) {
        this.evalDuration = evalDuration;
    }

    @Override
    public String toString() {
        return "DolphinResponse{" +
            "model='" + model + '\'' +
            ", createdAt='" + createdAt + '\'' +
            ", response='" + response + '\'' +
            ", done=" + done +
            ", totalDuration=" + totalDuration +
            ", loadDuration=" + loadDuration +
            ", promptEvalCount=" + promptEvalCount +
            ", promptEvalDuration=" + promptEvalDuration +
            ", evalCount=" + evalCount +
            ", evalDuration=" + evalDuration +
            '}';
    }
}



File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/dolphin/DolphinClient.java
package ee.tenman.mmse.service.external.dolphin;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;


@FeignClient(name = "dolphinClient", url = "http://127.0.0.1:11434")
public interface DolphinClient {
    @PostMapping("/api/generate")
    DolphinResponse generate(@RequestBody DolphinRequest request);
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/dolphin/DolphinRequest.java
package ee.tenman.mmse.service.external.dolphin;

public class DolphinRequest {

    private final String model = "dolphin-mixtral";
    private final boolean stream = false;
    private String prompt;

    public DolphinRequest(String prompt) {
        this.prompt = prompt;
    }

    public String getModel() {
        return model;
    }

    public String getPrompt() {
        return prompt;
    }

    public void setPrompt(String prompt) {
        this.prompt = prompt;
    }

    public boolean isStream() {
        return stream;
    }

    @Override
    public String toString() {
        return "DolphinRequest{" +
            "model='" + model + '\'' +
            ", prompt='" + prompt + '\'' +
            ", stream=" + stream +
            '}';
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/dolphin/DolphinService.java
package ee.tenman.mmse.service.external.dolphin;

import ee.tenman.mmse.service.external.openai.NoDolphinResponseException;
import jakarta.annotation.Resource;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.Optional;

@Service
public class DolphinService {

    private static final Logger log = LoggerFactory.getLogger(DolphinService.class);

    @Resource
    private DolphinClient dolphinClient;

    public String checkWithDolphinService(String prompt) {
        Optional<String> response = askQuestion(prompt);
        if (response.isEmpty()) {
            log.debug("Answer '{}' was not recognized as correct by Dolphin Service.", prompt);
            throw new NoDolphinResponseException("Dolphin Service returned no response");
        }

        response.ifPresent(r -> log.info("Dolphin Response: {}", r.toLowerCase()));
        return response.get().toLowerCase();
    }

    private Optional<String> askQuestion(String question) {
        if (StringUtils.isBlank(question)) {
            log.warn("Received blank question, returning empty response");
            return Optional.empty();
        }

        try {
            DolphinRequest request = new DolphinRequest(question);
            log.info("Generating: {}", request);
            DolphinResponse response = dolphinClient.generate(request);
            log.info("Dolphin response: {}", response);
            return Optional.ofNullable(response.getResponse());
        } catch (Exception e) {
            log.error("Failed to ask question: {}", question, e);
            return Optional.empty();
        }
    }

}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/prediction/PredictionClient.java
package ee.tenman.mmse.service.external.prediction;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

@FeignClient(name = "predictionClient", url = "http://127.0.0.1:61234")
public interface PredictionClient {

    @PostMapping("/predict")
    PredictionResponse predict(@RequestBody PredictionRequest request);

}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/prediction/PredictionRequest.java
package ee.tenman.mmse.service.external.prediction;

public class PredictionRequest {
    private String sentence;

    public PredictionRequest(String sentence) {
        this.sentence = sentence;
    }

    public String getSentence() {
        return sentence;
    }

    public void setSentence(String sentence) {
        this.sentence = sentence;
    }

    public String toString() {
        return "PredictionRequest{" +
                "sentence=" + sentence +
                '}';
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/prediction/PredictionResponse.java
package ee.tenman.mmse.service.external.prediction;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;

public class PredictionResponse {

    private boolean grammaticallyCorrect;

    @JsonCreator
    public PredictionResponse(@JsonProperty("grammatically_correct") boolean grammaticallyCorrect) {
        this.grammaticallyCorrect = grammaticallyCorrect;
    }

    public boolean isGrammaticallyCorrect() {
        return grammaticallyCorrect;
    }

    public void setGrammaticallyCorrect(boolean grammaticallyCorrect) {
        this.grammaticallyCorrect = grammaticallyCorrect;
    }

    @Override
    public String toString() {
        return "PredictionResponse{" +
                "grammaticallyCorrect=" + grammaticallyCorrect +
                '}';
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/prediction/PredictionService.java
package ee.tenman.mmse.service.external.prediction;

import jakarta.annotation.Resource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;


@Service
public class PredictionService {

    private static final Logger log = LoggerFactory.getLogger(PredictionService.class);

    @Resource
    private PredictionClient predictionClient;

    public boolean isGrammaticallyCorrect(String sentence) {
        log.info("Checking if sentence is grammatically correct: {}", sentence);
        PredictionRequest request = new PredictionRequest(sentence);
        PredictionResponse response = predictionClient.predict(request);
        log.info("Prediction response: {}", response);
        return response.isGrammaticallyCorrect();
    }

}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/similarity/SimilarityService.java
package ee.tenman.mmse.service.external.similarity;

import jakarta.annotation.Resource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;


@Service
public class SimilarityService {

    private static final Logger log = LoggerFactory.getLogger(SimilarityService.class);

    private static final double SIMILARITY_UPPER_LIMIT = 0.6;

    @Resource
    private SimilarityClient similarityClient;

    public boolean isSimilar(SimilarityRequest request) {
        log.info("Checking similarity. Similarity request: {}", request);
        SimilarityResponse response = similarityClient.compare(request);
        log.info("Similarity response: {}", response);
        return response.getSimilarity() >= SIMILARITY_UPPER_LIMIT;
    }

}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/similarity/SimilarityResponse.java
package ee.tenman.mmse.service.external.similarity;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;

public class SimilarityResponse {

    private double similarity;

    @JsonCreator
    public SimilarityResponse(@JsonProperty("similarity") double similarity) {
        this.similarity = similarity;
    }

    public double getSimilarity() {
        return similarity;
    }

    public void setSimilarity(double similarity) {
        this.similarity = similarity;
    }

    @Override
    public String toString() {
        return "SimilarityResponse{" +
            "similarity=" + similarity +
            '}';
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/similarity/SimilarityClient.java
package ee.tenman.mmse.service.external.similarity;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

@FeignClient(name = "similarityClient", url = "http://127.0.0.1:61237")
public interface SimilarityClient {

    @PostMapping("/compare")
    SimilarityResponse compare(@RequestBody SimilarityRequest request);

}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/similarity/SimilarityRequest.java
package ee.tenman.mmse.service.external.similarity;

public class SimilarityRequest {
    private String sentence1;
    private String sentence2;

    public SimilarityRequest() {
    }

    public SimilarityRequest(String sentence1, String sentence2) {
        this.sentence1 = sentence1;
        this.sentence2 = sentence2;
    }

    public String getSentence1() {
        return sentence1;
    }

    public void setSentence1(String sentence1) {
        this.sentence1 = sentence1;
    }

    public String getSentence2() {
        return sentence2;
    }

    public void setSentence2(String sentence2) {
        this.sentence2 = sentence2;
    }

    @Override
    public String toString() {
        return "SimilarityRequest{" +
            "sentence1='" + sentence1 + '\'' +
            ", sentence2='" + sentence2 + '\'' +
            '}';
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/minio/StorageService.java
package ee.tenman.mmse.service.external.minio;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;
import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;
import software.amazon.awssdk.core.ResponseBytes;
import software.amazon.awssdk.core.exception.SdkException;
import software.amazon.awssdk.core.sync.RequestBody;
import software.amazon.awssdk.core.sync.ResponseTransformer;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.s3.S3Client;
import software.amazon.awssdk.services.s3.model.GetObjectRequest;
import software.amazon.awssdk.services.s3.model.GetObjectResponse;
import software.amazon.awssdk.services.s3.model.PutObjectRequest;

import java.io.IOException;
import java.net.URI;
import java.util.UUID;

@Service
public class StorageService {

    private static final Logger log = LoggerFactory.getLogger(StorageService.class);

    private final String bucketName;
    private final S3Client s3Client;

    public StorageService(@Value("${minio.url}") String minioUrl,
                          @Value("${minio.access-key}") String accessKey,
                          @Value("${minio.secret-key}") String secretKey,
                          @Value("${minio.bucket-name}") String bucketName) {
        this.bucketName = bucketName;
        this.s3Client = S3Client.builder()
                .endpointOverride(URI.create(minioUrl))
                .region(Region.EU_CENTRAL_1)
                .credentialsProvider(StaticCredentialsProvider.create(AwsBasicCredentials.create(accessKey, secretKey)))
                .build();
    }

    public UUID uploadFile(MultipartFile file) {
        log.info("Uploading file: {}", file.getOriginalFilename());
        try {
            UUID fileId = UUID.randomUUID();
            String fileName = fileId + "_" + file.getOriginalFilename();

            PutObjectRequest putObjectRequest = PutObjectRequest.builder()
                .bucket(bucketName)
                .key(fileName)
                .build();

            s3Client.putObject(putObjectRequest, RequestBody.fromBytes(file.getBytes()));
            return fileId;
        } catch (SdkException e) {
            log.error("Error uploading file: {}", e.getMessage());
            throw new RuntimeException("Error uploading file to S3", e);
        } catch (IOException e) {
            log.error("IO Error: {}", e.getMessage());
            throw new RuntimeException("IO Error", e);
        }
    }

    public void uploadFile(MultipartFile file, String fileName) {
        log.info("Uploading file: {}", fileName);
        try {
            PutObjectRequest putObjectRequest = PutObjectRequest.builder()
                .bucket(bucketName)
                .key(fileName)
                .build();

            s3Client.putObject(putObjectRequest, RequestBody.fromBytes(file.getBytes()));
        } catch (SdkException e) {
            log.error("Error uploading file: {}", e.getMessage());
            throw new RuntimeException("Error uploading file to S3", e);
        } catch (IOException e) {
            log.error("IO Error: {}", e.getMessage());
            throw new RuntimeException("IO Error", e);
        }
    }


    public byte[] downloadFile(String fileName) {
        log.info("Downloading file: {}", fileName);
        try {
            GetObjectRequest getObjectRequest = GetObjectRequest.builder()
                    .bucket(bucketName)
                    .key(fileName)
                    .build();

            ResponseBytes<GetObjectResponse> objectBytes = s3Client.getObject(getObjectRequest,
                    ResponseTransformer.toBytes());

            log.info("File downloaded successfully: {}", fileName);
            return objectBytes.asByteArray();
        } catch (SdkException e) {
            log.error("Error downloading file: {}", e.getMessage());
            throw new RuntimeException("Error downloading file from S3", e);
        }
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/openai/NoDolphinResponseException.java
package ee.tenman.mmse.service.external.openai;

public class NoDolphinResponseException extends RuntimeException {
    public NoDolphinResponseException(String message) {
        super(message);
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/openai/OpenAiService.java
package ee.tenman.mmse.service.external.openai;

import jakarta.annotation.Resource;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.Optional;

@Service
public class OpenAiService {

    private static final Logger log = LoggerFactory.getLogger(OpenAiService.class);

    @Resource
    private OpenAiClient openAiClient;

    public Optional<String> askQuestion(String question) {
        if (StringUtils.isBlank(question)) {
            log.warn("Received blank question, returning empty response");
            return Optional.empty();
        }

        try {
            OpenAiRequest request = OpenAiRequest.createWithUserMessage(question);
            OpenAiResponse openAiResponse = openAiClient.askQuestion(request);
            return openAiResponse.getAnswer();
        } catch (Exception e) {
            log.error("Failed to ask question: {}", question, e);
            return Optional.empty();
        }
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/openai/OpenAiResponse.java
package ee.tenman.mmse.service.external.openai;

import java.util.List;
import java.util.Map;
import java.util.Optional;

public class OpenAiResponse {
    private static final String CONTENT = "content";
    private static final String MESSAGE = "message";

    private List<Map<String, Object>> choices;

    public OpenAiResponse() {
    }

    public OpenAiResponse(List<Map<String, Object>> choices) {
        this.choices = choices;
    }

    public List<Map<String, Object>> getChoices() {
        return choices;
    }

    public void setChoices(List<Map<String, Object>> choices) {
        this.choices = choices;
    }

    public Optional<String> getAnswer() {
        if (choices == null || choices.isEmpty()) {
            return Optional.empty();
        }

        Object messageObject = choices.get(0).get(MESSAGE);
        if (!(messageObject instanceof Map<?, ?> messageMap)) {
            return Optional.empty();
        }

        Object contentObject = messageMap.get(CONTENT);
        if (!(contentObject instanceof String content)) {
            return Optional.empty();
        }

        return Optional.of(content);
    }


    @Override
    public String toString() {
        return "OpenAiResponse{" +
            "choices=" + choices +
            '}';
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/openai/OpenAiRequest.java
package ee.tenman.mmse.service.external.openai;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class OpenAiRequest {
    private static final String DEFAULT_MODEL = "gpt-4";
//    private static final String DEFAULT_MODEL = "gpt-4-1106-preview";


    private static final String ROLE = "role";
    private static final String USER = "user";
    private static final String CONTENT = "content";

    private String model;
    private List<Map<String, String>> messages;

    public OpenAiRequest() {
        this.model = DEFAULT_MODEL;
    }

    public OpenAiRequest(String model, List<Map<String, String>> messages) {
        this.model = model;
        this.messages = messages;
    }

    public OpenAiRequest(List<Map<String, String>> messages) {
        this.model = DEFAULT_MODEL;
        this.messages = messages;
    }

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public List<Map<String, String>> getMessages() {
        return messages;
    }

    public void setMessages(List<Map<String, String>> messages) {
        this.messages = messages;
    }

    public static OpenAiRequest createWithUserMessage(String messageContent) {
        Map<String, String> userMessage = new HashMap<>();
        userMessage.put(ROLE, USER);
        userMessage.put(CONTENT, messageContent);

        OpenAiRequest request = new OpenAiRequest();
        request.setMessages(Collections.singletonList(userMessage));
        return request;
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/openai/OpenAiClient.java
package ee.tenman.mmse.service.external.openai;

import feign.RequestInterceptor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.context.annotation.Bean;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

@FeignClient(name = OpenAiClient.CLIENT_NAME, url = OpenAiClient.CLIENT_URL, configuration = OpenAiClient.Configuration.class)
public interface OpenAiClient {

    String CLIENT_NAME = "openAiClient";
    String CLIENT_URL = "https://api.openai.com";

    @PostMapping("/v1/chat/completions")
    OpenAiResponse askQuestion(@RequestBody OpenAiRequest request);

    class Configuration {
        @Value("${openai.token}")
        private String openAiToken;

        @Bean
        public RequestInterceptor requestInterceptor() {
            return template -> template.header("Authorization", "Bearer " + openAiToken);
        }
    }

}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/service/external/openai/NoOpenAiResponseException.java
package ee.tenman.mmse.service.external.openai;

public class NoOpenAiResponseException extends RuntimeException {
    public NoOpenAiResponseException(String message) {
        super(message);
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/domain/AbstractAuditingEntity.java
package ee.tenman.mmse.domain;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import org.springframework.data.annotation.CreatedBy;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedBy;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.io.Serializable;
import java.time.Instant;

/**
 * Base abstract class for entities which will hold definitions for created, last modified, created by,
 * last modified by attributes.
 */
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
@JsonIgnoreProperties(value = {"createdBy", "createdDate", "lastModifiedBy", "lastModifiedDate"}, allowGetters = true)
public abstract class AbstractAuditingEntity<T> implements Serializable {

    private static final long serialVersionUID = 1L;

    public abstract T getId();

    @CreatedBy
    @Column(name = "created_by", nullable = false, length = 50, updatable = false)
    private String createdBy;

    @CreatedDate
    @Column(name = "created_date", updatable = false)
    private Instant createdDate = Instant.now();

    @LastModifiedBy
    @Column(name = "last_modified_by", length = 50)
    private String lastModifiedBy;

    @LastModifiedDate
    @Column(name = "last_modified_date")
    private Instant lastModifiedDate = Instant.now();

    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }

    public Instant getCreatedDate() {
        return createdDate;
    }

    public void setCreatedDate(Instant createdDate) {
        this.createdDate = createdDate;
    }

    public String getLastModifiedBy() {
        return lastModifiedBy;
    }

    public void setLastModifiedBy(String lastModifiedBy) {
        this.lastModifiedBy = lastModifiedBy;
    }

    public Instant getLastModifiedDate() {
        return lastModifiedDate;
    }

    public void setLastModifiedDate(Instant lastModifiedDate) {
        this.lastModifiedDate = lastModifiedDate;
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/domain/User.java
package ee.tenman.mmse.domain;

import com.fasterxml.jackson.annotation.JsonIgnore;
import ee.tenman.mmse.config.Constants;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.SequenceGenerator;
import jakarta.persistence.Table;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import org.apache.commons.lang3.StringUtils;
import org.hibernate.annotations.BatchSize;

import java.io.Serializable;
import java.time.Instant;
import java.util.HashSet;
import java.util.Locale;
import java.util.Set;

/**
 * A user.
 */
@Entity
@Table(name = "mmse_user")
public class User extends AbstractAuditingEntity<Long> implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "sequenceGenerator")
    @SequenceGenerator(name = "sequenceGenerator")
    private Long id;

    @NotNull
    @Pattern(regexp = Constants.LOGIN_REGEX)
    @Size(min = 1, max = 50)
    @Column(length = 50, unique = true, nullable = false)
    private String login;

    @JsonIgnore
    @NotNull
    @Size(min = 60, max = 60)
    @Column(name = "password_hash", length = 60, nullable = false)
    private String password;

    @Size(max = 50)
    @Column(name = "first_name", length = 50)
    private String firstName;

    @Size(max = 50)
    @Column(name = "last_name", length = 50)
    private String lastName;

    @Email
    @Size(min = 5, max = 254)
    @Column(length = 254, unique = true)
    private String email;

    @NotNull
    @Column(nullable = false)
    private boolean activated = false;

    @Size(min = 2, max = 10)
    @Column(name = "lang_key", length = 10)
    private String langKey;

    @Size(max = 256)
    @Column(name = "image_url", length = 256)
    private String imageUrl;

    @Size(max = 20)
    @Column(name = "activation_key", length = 20)
    @JsonIgnore
    private String activationKey;

    @Size(max = 20)
    @Column(name = "reset_key", length = 20)
    @JsonIgnore
    private String resetKey;

    @Column(name = "reset_date")
    private Instant resetDate = null;

    @JsonIgnore
    @ManyToMany
    @JoinTable(
        name = "mmse_user_authority",
        joinColumns = {@JoinColumn(name = "user_id", referencedColumnName = "id")},
        inverseJoinColumns = {@JoinColumn(name = "authority_name", referencedColumnName = "name")}
    )
    @BatchSize(size = 20)
    private Set<Authority> authorities = new HashSet<>();

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getLogin() {
        return login;
    }

    // Lowercase the login before saving it in database
    public void setLogin(String login) {
        this.login = StringUtils.lowerCase(login, Locale.ENGLISH);
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getImageUrl() {
        return imageUrl;
    }

    public void setImageUrl(String imageUrl) {
        this.imageUrl = imageUrl;
    }

    public boolean isActivated() {
        return activated;
    }

    public void setActivated(boolean activated) {
        this.activated = activated;
    }

    public String getActivationKey() {
        return activationKey;
    }

    public void setActivationKey(String activationKey) {
        this.activationKey = activationKey;
    }

    public String getResetKey() {
        return resetKey;
    }

    public void setResetKey(String resetKey) {
        this.resetKey = resetKey;
    }

    public Instant getResetDate() {
        return resetDate;
    }

    public void setResetDate(Instant resetDate) {
        this.resetDate = resetDate;
    }

    public String getLangKey() {
        return langKey;
    }

    public void setLangKey(String langKey) {
        this.langKey = langKey;
    }

    public Set<Authority> getAuthorities() {
        return authorities;
    }

    public void setAuthorities(Set<Authority> authorities) {
        this.authorities = authorities;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof User)) {
            return false;
        }
        return id != null && id.equals(((User) o).id);
    }

    @Override
    public int hashCode() {
        // see https://vladmihalcea.com/how-to-implement-equals-and-hashcode-using-the-jpa-entity-identifier/
        return getClass().hashCode();
    }

    // prettier-ignore
    @Override
    public String toString() {
        return "User{" +
            "login='" + login + '\'' +
            ", firstName='" + firstName + '\'' +
            ", lastName='" + lastName + '\'' +
            ", email='" + email + '\'' +
            ", imageUrl='" + imageUrl + '\'' +
            ", activated='" + activated + '\'' +
            ", langKey='" + langKey + '\'' +
            ", activationKey='" + activationKey + '\'' +
            "}";
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/domain/UserAnswer.java
package ee.tenman.mmse.domain;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import ee.tenman.mmse.domain.enumeration.QuestionId;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.PrePersist;
import jakarta.persistence.PreUpdate;
import jakarta.persistence.SequenceGenerator;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotNull;

import java.io.Serializable;
import java.time.Instant;

/**
 * A UserAnswer.
 */
@Entity
@Table(name = "user_answer")
@SuppressWarnings("common-java:DuplicatedBlocks")
public class UserAnswer implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "sequenceGenerator")
    @SequenceGenerator(name = "sequenceGenerator")
    @Column(name = "id")
    private Long id;

    @Column(name = "answer_text")
    private String answerText;

    @NotNull
    @Column(name = "created_at", nullable = false)
    private Instant createdAt = Instant.now();

    @Column(name = "updated_at")
    private Instant updatedAt;

    @Column(name = "score")
    private Integer score;

    @Column(name = "maximum_score")
    private Integer maximumScore;

    @NotNull
    @Enumerated(EnumType.STRING)
    @Column(name = "question_id", nullable = false)
    private QuestionId questionId;

    @ManyToOne(optional = false)
    @NotNull
    @JsonIgnoreProperties(value = {"user"}, allowSetters = true)
    private TestEntity testEntity;

    @PrePersist
    public void prePersist() {
        this.createdAt = Instant.now();
        this.updatedAt = Instant.now(); // Set updatedAt on insert as well.
    }

    @PreUpdate
    public void preUpdate() {
        this.updatedAt = Instant.now(); // Update the updatedAt field before update.
    }

    // jhipster-needle-entity-add-field - JHipster will add fields here

    public Long getId() {
        return this.id;
    }

    public UserAnswer id(Long id) {
        this.setId(id);
        return this;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getAnswerText() {
        return this.answerText;
    }

    public UserAnswer answerText(String answerText) {
        this.setAnswerText(answerText);
        return this;
    }

    public void setAnswerText(String answerText) {
        this.answerText = answerText;
    }

    public Instant getCreatedAt() {
        return this.createdAt;
    }

    public UserAnswer createdAt(Instant createdAt) {
        this.setCreatedAt(createdAt);
        return this;
    }

    public void setCreatedAt(Instant createdAt) {
        this.createdAt = createdAt;
    }

    public Instant getUpdatedAt() {
        return this.updatedAt;
    }

    public UserAnswer updatedAt(Instant updatedAt) {
        this.setUpdatedAt(updatedAt);
        return this;
    }

    public void setUpdatedAt(Instant updatedAt) {
        this.updatedAt = updatedAt;
    }

    public QuestionId getQuestionId() {
        return this.questionId;
    }

    public UserAnswer questionId(QuestionId questionId) {
        this.setQuestionId(questionId);
        return this;
    }

    public void setQuestionId(QuestionId questionId) {
        this.questionId = questionId;
    }

    public TestEntity getTestEntity() {
        return this.testEntity;
    }

    public void setTestEntity(TestEntity testEntity) {
        this.testEntity = testEntity;
    }

    public Integer getScore() {
        return this.score;
    }

    public void setScore(Integer score) {
        this.score = score;
    }

    public UserAnswer testEntity(TestEntity testEntity) {
        this.setTestEntity(testEntity);
        return this;
    }

    public Integer getMaximumScore() {
        return this.maximumScore;
    }

    public void setMaximumScore(Integer maximumScore) {
        this.maximumScore = maximumScore;
    }

    // jhipster-needle-entity-add-getters-setters - JHipster will add getters and setters here

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof UserAnswer)) {
            return false;
        }
        return id != null && id.equals(((UserAnswer) o).id);
    }

    @Override
    public int hashCode() {
        // see https://vladmihalcea.com/how-to-implement-equals-and-hashcode-using-the-jpa-entity-identifier/
        return getClass().hashCode();
    }

    // prettier-ignore

    @Override
    public String toString() {
        return "UserAnswer{" +
            "id=" + id +
            ", answerText='" + answerText + '\'' +
            ", createdAt=" + createdAt +
            ", updatedAt=" + updatedAt +
            ", score=" + score +
            ", maximumScore=" + maximumScore +
            ", questionId=" + questionId +
            '}';
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/domain/Authority.java
package ee.tenman.mmse.domain;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

import java.io.Serializable;
import java.util.Objects;

/**
 * An authority (a security role) used by Spring Security.
 */
@Entity
@Table(name = "mmse_authority")
public class Authority implements Serializable {

    private static final long serialVersionUID = 1L;

    @NotNull
    @Size(max = 50)
    @Id
    @Column(length = 50)
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof Authority)) {
            return false;
        }
        return Objects.equals(name, ((Authority) o).name);
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(name);
    }

    // prettier-ignore
    @Override
    public String toString() {
        return "Authority{" +
            "name='" + name + '\'' +
            "}";
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/domain/MediaRecording.java
package ee.tenman.mmse.domain;

import ee.tenman.mmse.domain.enumeration.QuestionId;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.SequenceGenerator;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotNull;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.Instant;

@Entity
@Table(name = "media_recording")
public class MediaRecording {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "sequenceGenerator")
    @SequenceGenerator(name = "sequenceGenerator")
    @Column(name = "id")
    private Long id;

    @Column(name = "file_name")
    private String fileName;

    @ManyToOne
    @JoinColumn(name = "test_entity_id")
    private TestEntity testEntity;

    @NotNull
    @Enumerated(EnumType.STRING)
    @Column(name = "question_id", nullable = false)
    private QuestionId questionId;

    @NotNull
    @Column(name = "created_at", nullable = false)
    @CreationTimestamp
    private Instant createdAt = Instant.now();

    @Column(name = "updated_at")
    @UpdateTimestamp
    private Instant updatedAt;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getFileName() {
        return fileName;
    }

    public void setFileName(String fileName) {
        this.fileName = fileName;
    }

    public TestEntity getTestEntity() {
        return testEntity;
    }

    public void setTestEntity(TestEntity testEntity) {
        this.testEntity = testEntity;
    }

    public QuestionId getQuestionId() {
        return questionId;
    }

    public void setQuestionId(QuestionId questionId) {
        this.questionId = questionId;
    }

    public Instant getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(Instant createdAt) {
        this.createdAt = createdAt;
    }

    public Instant getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(Instant updatedAt) {
        this.updatedAt = updatedAt;
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/domain/TestEntity.java
package ee.tenman.mmse.domain;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.SequenceGenerator;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotNull;

import java.io.Serializable;
import java.time.Instant;

/**
 * A TestEntity.
 */
@Entity
@Table(name = "test_entity")
@SuppressWarnings("common-java:DuplicatedBlocks")
public class TestEntity implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "sequenceGenerator")
    @SequenceGenerator(name = "sequenceGenerator")
    @Column(name = "id")
    private Long id;

    @NotNull
    @Column(name = "created_at", nullable = false)
    private Instant createdAt = Instant.now();

    @Column(name = "updated_at")
    private Instant updatedAt;

    @Column(name = "score")
    private Integer score;

    @ManyToOne(optional = false)
    @NotNull
    private User user;

    // jhipster-needle-entity-add-field - JHipster will add fields here

    public Long getId() {
        return this.id;
    }

    public TestEntity id(Long id) {
        this.setId(id);
        return this;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Instant getCreatedAt() {
        return this.createdAt;
    }

    public TestEntity createdAt(Instant createdAt) {
        this.setCreatedAt(createdAt);
        return this;
    }

    public void setCreatedAt(Instant createdAt) {
        this.createdAt = createdAt;
    }

    public Instant getUpdatedAt() {
        return this.updatedAt;
    }

    public TestEntity updatedAt(Instant updatedAt) {
        this.setUpdatedAt(updatedAt);
        return this;
    }

    public void setUpdatedAt(Instant updatedAt) {
        this.updatedAt = updatedAt;
    }

    public Integer getScore() {
        return this.score;
    }

    public TestEntity score(Integer score) {
        this.setScore(score);
        return this;
    }

    public void setScore(Integer score) {
        this.score = score;
    }

    public User getUser() {
        return this.user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public TestEntity user(User user) {
        this.setUser(user);
        return this;
    }

    // jhipster-needle-entity-add-getters-setters - JHipster will add getters and setters here

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof TestEntity)) {
            return false;
        }
        return id != null && id.equals(((TestEntity) o).id);
    }

    @Override
    public int hashCode() {
        // see https://vladmihalcea.com/how-to-implement-equals-and-hashcode-using-the-jpa-entity-identifier/
        return getClass().hashCode();
    }

    // prettier-ignore
    @Override
    public String toString() {
        return "TestEntity{" +
            "id=" + getId() +
            ", createdAt='" + getCreatedAt() + "'" +
            ", updatedAt='" + getUpdatedAt() + "'" +
            ", score=" + getScore() +
            "}";
    }
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/domain/package-info.java
/**
 * Domain objects.
 */
package ee.tenman.mmse.domain;


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/domain/enumeration/AnswerOption.java
package ee.tenman.mmse.domain.enumeration;

public enum AnswerOption {
    CAR,
    BALL,
    MAN,
    TREE,
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/domain/enumeration/QuestionType.java
package ee.tenman.mmse.domain.enumeration;

public enum QuestionType {
    MULTIPLE_CHOICE, // For multiple choice questions
    TEXT_INPUT,      // For text input questions
    MULTIPLE_TEXT_INPUT, // For multiple text input questions
    NUMERIC_INPUT,   // For numeric input questions
    SUBTRACTION_TASK, // For subtraction tasks
    VOICE_INPUT, // For voice input questions
    DRAG_AND_DROP // For drag and drop questions
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/domain/enumeration/QuestionId.java
package ee.tenman.mmse.domain.enumeration;

/**
 * The QuestionId enumeration.
 */
public enum QuestionId {
    FIRST,
    QUESTION_1,
    QUESTION_2,
    QUESTION_3,
    QUESTION_4,
    QUESTION_5,
    QUESTION_6,
    QUESTION_7,
    QUESTION_8,
    QUESTION_9,
    QUESTION_10,
    QUESTION_11,
    QUESTION_12,
    QUESTION_13,
    QUESTION_14,
    QUESTION_15,
    QUESTION_16,
//    QUESTION_17,
//    QUESTION_18,
}


File: /Users/tenman/MMSE-App/src/main/java/ee/tenman/mmse/domain/enumeration/package-info.java
/**
 * This package file was generated by JHipster
 */
package ee.tenman.mmse.domain.enumeration;


